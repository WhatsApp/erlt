-module(gadt_header).

-export([gen/1]).

-include("service.hrl").

%% erlfmt-ignore
gen(Service = #service{singleton = false}) ->
    Calls = Service#service.calls,
    Casts = Service#service.casts,
    RPCs = Calls ++ Casts,
    "%% generated by rpctc gadtheader\n"
    "-behaviour(gen_server).\n"
    "\n"
    "-export([" ++ m(fun fa_str_plus1/1, RPCs) ++ "]).\n"
    "\n"
    "-export([" ++ m(fun fa_handle_str/1, RPCs) ++ "]).\n"
    "\n"
    "-export([handle_call/3, handle_cast/2, init/1]).\n"
    "\n"
    "-include(\"stdt.hrl\").\n"
    "\n"
    "-callback handle_init(input()) -> state().\n"
    "" ++ lists:join("\n", lists:map(fun gen_callback/1, RPCs)) ++ "\n"
    "\n"
    "%% This is an enum that approximates the GADT below\n"
    "-enum call_request() :: (\n"
    "    " ++ lists:join(",\n    ", lists:map(fun enum_const_str/1, Calls)) ++ "\n"
    ").\n"
    "\n"
    "%% This generalized enum, that properly types handle_call\n"
    "%% -genum call_request(Result) :: {\n"
    "%%     " ++ lists:join(",\n%%     ", lists:map(fun genum_const_str/1, Calls)) ++ "\n"
    "%% }.\n"
    "%% Waiting on https://github.com/WhatsApp/erlt/issues/269 to uncomment this.\n"
    "\n"
    "-enum cast_request() :: (\n"
    "    " ++ lists:join(",\n    ", lists:map(fun enum_const_str/1, Casts)) ++ "\n"
    ").\n"
    "\n"
    "-spec service_start({registration(), gen_server:name()}, input()) -> ok_value(pid()).\n"
    "service_start(RegistrationScheme, InitArgs) ->\n"
    "    RScheme =\n"
    "        case RegistrationScheme of\n"
    "            {registration.local{}, Name} -> {local, Name};\n"
    "            {registration.global{}, Name} -> {global, Name}\n"
    "        end,\n"
    "    {ok, Pid} = gen_server:start_link(RScheme, ?MODULE, InitArgs, []),\n"
    "    ok_value.ok{Pid}.\n"
    "\n"
    "-spec service_stop(gen_server:name()) -> ok().\n"
    "service_stop(Name) ->\n"
    "    ok = gen_server:stop(Name),\n"
    "    ok.ok{}.\n"
    "\n"
    "" ++ lists:join("\n", lists:map(fun gen_call_with_name/1, RPCs)) ++ "\n"
    "-spec init(input()) -> atom_ok_value(state()).\n"
    "init(InitState) ->\n"
    "    State = handle_init(InitState),\n"
    "    {ok, State}.\n"
    "\n"
    "-spec handle_cast(cast_request(), state()) -> atom_noreply(state()).\n"
    "" ++ lists:join(";\n", lists:map(fun handle_cast_str/1, Casts)) ++ ".\n"
    "\n"
    "%% This is what the spec would like with a GADT\n"
    "%% -spec handle_call(call_request(Result), pid(), state()) -> atom_reply(Result, state()).\n"
    "" ++ lists:join(";\n", lists:map(fun handle_call_str/1, Calls)) ++ ".\n"
    ;
gen(Service = #service{singleton = true}) ->
    Calls = Service#service.calls,
    Casts = Service#service.casts,
    RPCs = Calls ++ Casts,
    "%% generated by rpctc gadtheader\n"
    "-behaviour(gen_server).\n"
    "\n"
    "-export([" ++ m(fun fa_str/1, RPCs) ++ "]).\n"
    "\n"
    "-export([" ++ m(fun fa_handle_str/1, RPCs) ++ "]).\n"
    "\n"
    "-export([handle_call/3, handle_cast/2, init/1]).\n"
    "\n"
    "-include(\"stdt.hrl\").\n"
    "\n"
    "-callback handle_init(input()) -> state().\n"
    "" ++ lists:join("\n", lists:map(fun gen_callback/1, RPCs)) ++ "\n"
    "\n"
    "%% This is an enum that approximates the GADT below\n"
    "-enum call_request() :: (\n"
    "    " ++ lists:join(",\n    ", lists:map(fun enum_const_str/1, Calls)) ++ "\n"
    ").\n"
    "\n"
    "%% This generalized enum, that properly types handle_call\n"
    "%% -genum call_request(Result) :: {\n"
    "%%     " ++ lists:join(",\n%%     ", lists:map(fun genum_const_str/1, Calls)) ++ "\n"
    "%% }.\n"
    "%% Waiting on https://github.com/WhatsApp/erlt/issues/269 to uncomment this.\n"
    "\n"
    "-enum cast_request() :: (\n"
    "    " ++ lists:join(",\n    ", lists:map(fun enum_const_str/1, Casts)) ++ "\n"
    ").\n"
    "\n"
    "-spec service_start(registration(), input()) -> ok_value(pid()).\n"
    "service_start(Registration, InitArgs) ->\n"
    "    RAtom =\n"
    "        case Registration of\n"
    "            registration.local{} -> local;\n"
    "            registration.global{} -> global\n"
    "        end,\n"
    "    {ok, Pid} = gen_server:start_link({RAtom, ?MODULE}, ?MODULE, InitArgs, []),\n"
    "    ok_value.ok{Pid}.\n"
    "\n"
    "-spec service_stop() -> ok().\n"
    "service_stop() ->\n"
    "    ok = gen_server:stop(?MODULE),\n"
    "    ok.ok{}.\n"
    "\n"
    "" ++ lists:join("\n", lists:map(fun gen_call/1, RPCs)) ++ "\n"
    "-spec init(input()) -> atom_ok_value(state()).\n"
    "init(InitState) ->\n"
    "    State = handle_init(InitState),\n"
    "    {ok, State}.\n"
    "\n"
    "-spec handle_cast(cast_request(), state()) -> atom_noreply(state()).\n"
    "" ++ lists:join(";\n", lists:map(fun handle_cast_str/1, Casts)) ++ ".\n"
    "\n"
    "%% This is what the spec would like with a GADT\n"
    "%% -spec handle_call(call_request(Result), pid(), state()) -> atom_reply(Result, state()).\n"
    "" ++ lists:join(";\n", lists:map(fun handle_call_str/1, Calls)) ++ ".\n"
    .

%% erlfmt-ignore
gen_callback(#cast{name = Name, params = Params}) ->
    "-callback handle_" ++ Name ++ "(" ++ lists:join(", ", Params) ++ ", state()) -> state().";
gen_callback(#call{name = Name, params = Params, return = Return}) ->
    "-callback handle_" ++ Name ++ "(" ++ lists:join(", ", Params) ++ ", state()) -> {" ++ Return ++ ", state()}.".

%% erlfmt-ignore
gen_call(#cast{name = Name, params = Params}) ->
    "-spec " ++ Name ++ "(" ++ lists:join(", ", Params) ++ ") -> ok().\n"
    "" ++ Name ++ "(" ++ lists:join(", ", args(0, Params)) ++ ") ->\n"
    "    ok = gen_server:cast(?MODULE, cast_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "}),\n"
    "    ok.ok{}.\n"
    ;
gen_call(#call{name = Name, params = Params, return = Return}) ->
    "-spec " ++ Name ++ "(" ++ lists:join(", ", Params) ++ ") -> " ++ Return ++ ".\n"
    "" ++ Name ++ "(" ++ lists:join(", ", args(0, Params)) ++ ") ->\n"
    "    gen_server:call(?MODULE, call_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "}).\n".

%% erlfmt-ignore
gen_call_with_name(#cast{name = Name, params = Params}) ->
    "-spec " ++ Name ++ "(gen_server:name(), " ++ lists:join(", ", Params) ++ ") -> ok().\n"
    "" ++ Name ++ "(Name, " ++ lists:join(", ", args(0, Params)) ++ ") ->\n"
    "    ok = gen_server:cast(Name, cast_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "}),\n"
    "    ok.ok{}.\n"
    ;
gen_call_with_name(#call{name = Name, params = Params, return = Return}) ->
    "-spec " ++ Name ++ "(gen_server:name(), " ++ lists:join(", ", Params) ++ ") -> " ++ Return ++ ".\n"
    "" ++ Name ++ "(Name, " ++ lists:join(", ", args(0, Params)) ++ ") ->\n"
    "    gen_server:call(Name, call_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "}).\n".

%% erlfmt-ignore
handle_cast_str(#cast{name = Name, params = Params}) ->
    "handle_cast(cast_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "}, State) ->\n"
    "    {noreply, (?MODULE:handle_" ++ Name ++ ")("  ++ lists:join(", ", args(0, Params)) ++ ", State)}".

%% erlfmt-ignore
handle_call_str(#call{name = Name, params = Params}) ->
    "handle_call(call_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "}, _From, State) ->\n"
    "    {Result, NewState} = (?MODULE:handle_" ++ Name ++ ")(" ++ lists:join(", ", args(0, Params)) ++ ", State),\n"
    "    {reply, Result, NewState}".

fa_str(#call{name = Name, params = Params}) ->
    Name ++ "/" ++ itoa(length(Params));
fa_str(#cast{name = Name, params = Params}) ->
    Name ++ "/" ++ itoa(length(Params)).

fa_str_plus1(#call{name = Name, params = Params}) ->
    Name ++ "/" ++ itoa(length(Params) + 1);
fa_str_plus1(#cast{name = Name, params = Params}) ->
    Name ++ "/" ++ itoa(length(Params) + 1).

fa_handle_str(#call{name = Name, params = Params}) ->
    "handle_" ++ Name ++ "/" ++ itoa(length(Params) + 1);
fa_handle_str(#cast{name = Name, params = Params}) ->
    "handle_" ++ Name ++ "/" ++ itoa(length(Params) + 1).

enum_const_str(#cast{name = Name, params = Params}) ->
    Name ++ "{" ++ lists:join(", ", Params) ++ "}";
enum_const_str(#call{name = Name, params = Params}) ->
    Name ++ "{" ++ lists:join(", ", Params) ++ "}".

genum_const_str(#call{name = Name, params = Params, return = Return}) ->
    Name ++ "(" ++ lists:join(", ", Params) ++ ") -> call_request(" ++ Return ++ ")".

m(Fun, List) ->
    lists:join(", ", lists:map(Fun, List)).

args(_, []) -> [];
args(N, [_ | Rest]) -> [("Arg" ++ itoa(N)) | args(N + 1, Rest)].

itoa(Int) ->
    lists:flatten(io_lib:format("~p", [Int])).
