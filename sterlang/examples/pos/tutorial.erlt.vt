val minimal/0: fun(() -> {})
val X: number()
val Y: number()
val basic_values/0: fun(() -> {})
val My_int: number()
val My_str: string()
val Empty_record: #()
val Unit: {}
val Tuple1: {number(), number()}
val Tuple2: {number(), string()}
val Int_list: list(number())
val My_profile_rec: #( languages :: list(string()), name :: string() )
val Location_rec: #( city :: string(), country :: string() )
val Bool1: boolean()
val Bool2: boolean()
val F_id: fun((A) -> A)
val X: A
val F_first: fun((B, C) -> B)
val X1: B
val Y1: C
val F_second: fun((D, E) -> E)
val X2: D
val Y2: E
val F_const: fun(() -> number())
val enums/0: fun(() -> {})
val None: core:option(A)
val SomeInt: core:option(number())
val SomeStr: core:option(string())
val L1: list(core:option(number()))
val L2: list(core:option(string()))
val id/1: fun((A) -> A)
val X: A
val mkSome/1: fun((A) -> core:option(A))
val X: A
val mkList/2: fun((A, A) -> list(A))
val E1: A
val E2: A
val funs/0: fun(() -> {})
val V1: core:option(number())
val V2: core:option(string())
val pieces/0: fun(() -> {})
val My_rec: #( n :: number(), st :: string(), z :: list(A) )
val NVal: number()
val N1: number()
val S1: string()
val Z1: list(B)
val N: number()
val St: string()
val Z: list(C)
val Rec1: #( n :: number(), z :: list(D) )
val NVal: number()
val My_rec1: #( n :: number(), st :: string(), z :: list(E) )
val My_pair: {number(), list(F)}
val Elem1: number()
val Elem2: list(G)
val list1/1: fun((list(A)) -> list(A))
val L: list(A)
val list2/1: fun((list(A)) -> list(B))
val L: list(A)
val list3/1: fun((list(A)) -> {A, list(A)})
val L: list(A)
val H: A
val T: list(A)
val list4/1: fun((list(A)) -> {A, A, A})
val L: list(A)
val E1: A
val E2: A
val E3: A
val map/2: fun((fun((A) -> B), list(A)) -> list(B))
val F: fun((A) -> B)
val Xs: list(A)
val X1: A
val Xs1: list(A)
val getIds/1: fun((list(#( id :: A, B ))) -> list(A))
val Recs: list(#( id :: A, B ))
val X: #( id :: A, B )
val global/2: fun((boolean(), A) -> A)
val X: boolean()
val V: A
val inside/1: fun((A) -> A)
val Y: A
val T: fun((boolean(), B) -> B)
val Local: fun((boolean(), C) -> C)
val X: boolean()
val V: C
val inside1/0: fun(() -> fun((A) -> A))
val T: fun((B) -> B)
val X: B
val inside2/0: fun(() -> fun((A) -> A))
val T: fun((B) -> B)
val Local: fun((C) -> C)
val X: C
val get_id/1: fun((#( id :: A, B )) -> A)
val R: #( id :: A, B )
val extract/1: fun((#( id :: A, B )) -> #( id :: A ))
val Id: A
val records_example/0: fun(() -> {})
val Id1: number()
val Id2: string()
val Rec1: #( id :: number() )
val Rec2: #( id :: number(), key :: number() )
val Rec_list: list(#( id :: number() ))
val id_rec/1: fun((#( A )) -> #( A ))
val R: #( A )
val get_id1/1: fun((#( id :: A, B )) -> A)
val Rec: #( id :: A, B )
val IdVal: A
val update_a_b/1: fun((#( a :: number(), b :: number(), A )) -> #( a :: number(), b :: number(), A ))
val R: #( a :: number(), b :: number(), A )
val swap_a_b/1: fun((#( a :: A, b :: A, B )) -> #( a :: A, b :: A, B ))
val R: #( a :: A, b :: A, B )
val id01/1: fun((A) -> A)
val A: A
val id02/1: fun((A) -> A)
val A: A
val id03/1: fun((A) -> A)
val A: A
val isDefined1/1: fun((my_option(A)) -> boolean())
val Opt: my_option(A)
val map1/2: fun((fun((A) -> B), my_list(A)) -> my_list(B))
val F: fun((A) -> B)
val Xs: my_list(A)
val X1: A
val Xs1: my_list(A)
val to_bools/1: fun((my_list(my_option(A))) -> my_list(boolean()))
val Xs: my_list(my_option(A))
val onlySome/1: fun((my_list(my_option(A))) -> my_list(my_option(A)))
val Xs: my_list(my_option(A))
val X1: my_option(A)
val Xs1: my_list(my_option(A))
val A: A
val dec_opt/1: fun((my_option(A)) -> number())
val Opt: my_option(A)
val dec_opt2/1: fun((my_option(A)) -> list(A))
val Opt: my_option(A)
val V: A
val dec_opt3/3: fun((my_option(fun((A) -> B)), A, A) -> list(B))
val Opt: my_option(fun((A) -> B))
val V1: A
val V2: A
val F: fun((A) -> B)
val dec_opt4/3: fun((A, B, C) -> {A, B, C})
val X: A
val Y: B
val Z: C
val Id: fun((D) -> D)
val X: D
val OptId: my_option(fun((E) -> E))
val Id1: fun((F) -> F)
val Id2: fun((G) -> G)
