val minimal/0: fun(() -> {})
val X: integer()
val Y: integer()
val basic_values/0: fun(() -> {})
val My_int: integer()
val My_str: string()
val Empty_record: #()
val Unit: {}
val Tuple1: {integer(), integer()}
val Tuple2: {integer(), string()}
val Int_list: list(integer())
val My_profile_rec: #( languages :: list(string()), name :: string() )
val Location_rec: #( city :: string(), country :: string() )
val Bool1: boolean()
val Bool2: boolean()
val F_id: fun((A) -> A)
val X: A
val F_first: fun((B, C) -> B)
val X1: B
val Y1: C
val F_second: fun((D, E) -> E)
val X2: D
val Y2: E
val F_const: fun(() -> integer())
val enums/0: fun(() -> {})
val None: core:option(A)
val SomeInt: core:option(integer())
val SomeStr: core:option(string())
val L1: list(core:option(integer()))
val L2: list(core:option(string()))
val id/1: fun((A) -> A)
val X: A
val mkSome/1: fun((A) -> core:option(A))
val X: A
val mkList/2: fun((A, A) -> list(A))
val E1: A
val E2: A
val funs/0: fun(() -> {})
val V1: core:option(integer())
val V2: core:option(string())
val pieces/0: fun(() -> {})
val My_rec: #( n :: integer(), st :: string(), z :: list(A) )
val NVal: integer()
val N1: integer()
val S1: string()
val Z1: list(B)
val N: integer()
val St: string()
val Z: list(C)
val Rec1: #( n :: integer(), z :: list(D) )
val NVal: integer()
val My_rec1: #( n :: integer(), st :: string(), z :: list(E) )
val My_pair: {integer(), list(F)}
val Elem1: integer()
val Elem2: list(G)
val list1/1: fun((list(A)) -> list(A))
val L: list(A)
val list2/1: fun((list(A)) -> list(B))
val L: list(A)
val list3/1: fun((list(A)) -> {A, list(A)})
val L: list(A)
val H: A
val T: list(A)
val list4/1: fun((list(A)) -> {A, A, A})
val L: list(A)
val E1: A
val E2: A
val E3: A
val map/2: fun((fun((A) -> B), list(A)) -> list(B))
val F: fun((A) -> B)
val Xs: list(A)
val X1: A
val Xs1: list(A)
val getIds/1: fun((list(#( id :: A, A ))) -> list(A))
val Recs: list(#( id :: A, A ))
val X: #( id :: A, A )
val global/2: fun((boolean(), A) -> A)
val X: boolean()
val V: A
val inside/1: fun((A) -> A)
val Y: A
val T: fun((boolean(), B) -> B)
val Local: fun((boolean(), C) -> C)
val X: boolean()
val V: C
val inside1/0: fun(() -> fun((A) -> A))
val T: fun((B) -> B)
val X: B
val inside2/0: fun(() -> fun((A) -> A))
val T: fun((B) -> B)
val Local: fun((C) -> C)
val X: C
val get_id/1: fun((#( id :: A, A )) -> A)
val R: #( id :: A, A )
val extract/1: fun((#( id :: A, A )) -> #( id :: A ))
val Id: A
val records_example/0: fun(() -> {})
val Id1: integer()
val Id2: string()
val Rec1: #( id :: integer() )
val Rec2: #( id :: integer(), key :: integer() )
val Rec_list: list(#( id :: integer() ))
val id_rec/1: fun((#( A )) -> #( A ))
val R: #( A )
val get_id1/1: fun((#( id :: A, A )) -> A)
val Rec: #( id :: A, A )
val IdVal: A
val update_a_b/1: fun((#( a :: integer(), b :: integer(), A )) -> #( a :: integer(), b :: integer(), A ))
val R: #( a :: integer(), b :: integer(), A )
val swap_a_b/1: fun((#( a :: A, b :: A, A )) -> #( a :: A, b :: A, A ))
val R: #( a :: A, b :: A, A )
val id01/1: fun((A) -> A)
val A: A
val id02/1: fun((A) -> A)
val A: A
val id03/1: fun((A) -> A)
val A: A
val isDefined1/1: fun((my_option(A)) -> boolean())
val Opt: my_option(A)
val map1/2: fun((fun((A) -> B), my_list(A)) -> my_list(B))
val F: fun((A) -> B)
val Xs: my_list(A)
val X1: A
val Xs1: my_list(A)
val to_bools/1: fun((my_list(my_option(A))) -> my_list(boolean()))
val Xs: my_list(my_option(A))
val onlySome/1: fun((my_list(my_option(A))) -> my_list(my_option(A)))
val Xs: my_list(my_option(A))
val X1: my_option(A)
val Xs1: my_list(my_option(A))
val A: A
val dec_opt/1: fun((my_option(A)) -> integer())
val Opt: my_option(A)
val dec_opt2/1: fun((my_option(A)) -> list(A))
val Opt: my_option(A)
val V: A
val dec_opt3/3: fun((my_option(fun((A) -> B)), A, A) -> list(B))
val Opt: my_option(fun((A) -> B))
val V1: A
val V2: A
val F: fun((A) -> B)
val dec_opt4/3: fun((A, B, C) -> {A, B, C})
val X: A
val Y: B
val Z: C
val Id: fun((D) -> D)
val X: D
val OptId: my_option(fun((E) -> E))
val Id1: fun((F) -> F)
val Id2: fun((G) -> G)
