val singleton/1: fun((A) -> list(A))
val Val: A
val repeat/2: fun((integer(), B) -> list(B))
val N: integer()
val Val: B
val repeat_help/3: fun((list(C), integer(), C) -> list(C))
val Res: list(C)
val N: integer()
val _Val: C
val Res: list(C)
val N: integer()
val Val: C
val range/2: fun((integer(), integer()) -> list(integer()))
val Lo: integer()
val Hi: integer()
val range_help/3: fun((integer(), integer(), list(integer())) -> list(integer()))
val Lo: integer()
val Hi: integer()
val L: list(integer())
val _Lo: integer()
val _Hi: integer()
val L: list(integer())
val cons/2: fun((D, list(D)) -> list(D))
val H: D
val T: list(D)
val map/2: fun((fun((E) -> F), list(E)) -> list(F))
val F: fun((E) -> F)
val H: E
val T: list(E)
val _F: fun((E) -> F)
val indexed_map/2: fun((fun((integer(), G) -> H), list(G)) -> list(H))
val F: fun((integer(), G) -> H)
val Xs: list(G)
val foldl/3: fun((fun((J, I) -> I), I, list(J)) -> I)
val F: fun((J, I) -> I)
val Acc: I
val H: J
val T: list(J)
val _F: fun((J, I) -> I)
val Acc: I
val foldr/3: fun((fun((L, K) -> K), K, list(L)) -> K)
val F: fun((L, K) -> K)
val Acc: K
val H: L
val T: list(L)
val _F: fun((L, K) -> K)
val Acc: K
val filter/2: fun((fun((M) -> boolean()), list(M)) -> list(M))
val F: fun((M) -> boolean())
val List: list(M)
val X: M
val Xs: list(M)
val filter_map/2: fun((fun((N) -> maybe:maybe(O)), list(N)) -> list(O))
val F: fun((N) -> maybe:maybe(O))
val Xs: list(N)
val maybe_cons/3: fun((fun((P) -> maybe:maybe(Q)), P, list(Q)) -> list(Q))
val F: fun((P) -> maybe:maybe(Q))
val Mx: P
val Xs: list(Q)
val X: Q
val maybe_cons/1: fun((fun((S) -> maybe:maybe(R))) -> fun((S, list(R)) -> list(R)))
val F: fun((S) -> maybe:maybe(R))
val Mx: S
val Xs: list(R)
val length/1: fun((list(T)) -> integer())
val Xs: list(T)
val I: integer()
val reverse/1: fun((list(U)) -> list(U))
val Xs: list(U)
val member/2: fun((V, list(V)) -> boolean())
val X: V
val Xs: list(V)
val all/2: fun((fun((W) -> boolean()), list(W)) -> boolean())
val Pred: fun((W) -> boolean())
val H: W
val T: list(W)
val _Pred: fun((W) -> boolean())
val any/2: fun((fun((X) -> boolean()), list(X)) -> boolean())
val Pred: fun((X) -> boolean())
val H: X
val T: list(X)
val _Pred: fun((X) -> boolean())
val maximum/1: fun((list(Y)) -> maybe:maybe(Y))
val H: Y
val T: list(Y)
val minimum/1: fun((list(Z)) -> maybe:maybe(Z))
val H: Z
val T: list(Z)
val sum/1: fun((list(integer())) -> integer())
val Ns: list(integer())
val product/1: fun((list(integer())) -> integer())
val Ns: list(integer())
val append/2: fun((list(T_26), list(T_26)) -> list(T_26))
val Xs: list(T_26)
val Ys: list(T_26)
val concat/1: fun((list(list(T_27))) -> list(T_27))
val Lists: list(list(T_27))
val concat_map/2: fun((fun((T_28) -> list(T_29)), list(T_28)) -> list(T_29))
val F: fun((T_28) -> list(T_29))
val Xs: list(T_28)
val intersperse/2: fun((T_30, list(T_30)) -> list(T_30))
val Sep: T_30
val H: T_30
val T: list(T_30)
val Step: fun((T_30, list(T_30)) -> list(T_30))
val X: T_30
val Rest: list(T_30)
val Spersed: list(T_30)
val _Sep: T_30
val map2/3: fun((fun((T_31, T_32) -> T_33), list(T_31), list(T_32)) -> list(T_33))
val F: fun((T_31, T_32) -> T_33)
val H1: T_31
val T1: list(T_31)
val H2: T_32
val T2: list(T_32)
val is_empty/1: fun((list(T_34)) -> boolean())
val head/1: fun((list(T_35)) -> maybe:maybe(T_35))
val H: T_35
val tail/1: fun((list(T_36)) -> maybe:maybe(list(T_36)))
val T: list(T_36)
val take/2: fun((integer(), list(T_37)) -> list(T_37))
val N: integer()
val _L: list(T_37)
val _N: integer()
val N: integer()
val H: T_37
val T: list(T_37)
val drop/2: fun((integer(), list(T_38)) -> list(T_38))
val N: integer()
val L: list(T_38)
val _N: integer()
val N: integer()
val _H: T_38
val T: list(T_38)
val partition/2: fun((fun((T_39) -> boolean()), list(T_39)) -> {list(T_39), list(T_39)})
val Pred: fun((T_39) -> boolean())
val List: list(T_39)
val Step: fun((T_39, {list(T_39), list(T_39)}) -> {list(T_39), list(T_39)})
val X: T_39
val Trues: list(T_39)
val Falses: list(T_39)
val unzip/1: fun((list({T_40, T_41})) -> {list(T_40), list(T_41)})
val Pairs: list({T_40, T_41})
val Step: fun(({T_42, T_43}, {list(T_42), list(T_43)}) -> {list(T_42), list(T_43)})
val X: T_42
val Y: T_43
val Xs: list(T_42)
val Ys: list(T_43)
