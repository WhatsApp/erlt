-file("mod01.erl", 1).

-module(mod01).

-compile(export_all).

-spec id(Arg1 :: X) -> X.

id(X) ->
    X.

-spec arg13(Arg1 :: X, _, _) -> X.

arg13(X, _Y, _Z) ->
    X.

-spec arg23(_, Arg2 :: Y, _) -> Y.

arg23(_X, Y, _Z) ->
    Y.

-spec arg33(_, _, Arg3 :: Z) -> Z.

arg33(_X, _Y, Z) ->
    Z.

-spec mk_int() -> integer().

mk_int() ->
    1.

-spec mk_float() -> integer().

mk_float() ->
    2.1231231.

-spec mk_string() -> string().

mk_string() ->
    "Erlang String".

-spec mk_char() -> char().

mk_char() ->
    $c.

-spec mk_nil() -> [_].

mk_nil() ->
    [].

-spec mk_cons(H :: A, T :: [A]) -> [A].

mk_cons(H, T) ->
    [H | T].

-spec mk_tuple(A, B, C) -> {A, B, C}.

mk_tuple(A, B, C) ->
    {A, B, C}.

-spec mk_tuple2(A) ->
                   {El1 :: integer(),
                    El2 :: integer(),
                    integer(),
                    El4 :: A}.

mk_tuple2(A) ->
    {1, 2, 3, A}.

-spec mk_map(A, B) -> #{a := A, b := B}.

mk_map(A, B) ->
    #{a => A, b => B}.

-spec update_map1(#{a := A}, A) -> #{a := A}.

update_map1(M, A) ->
    M#{a := A}.

-spec update_map3(#{a := A, b := A}) -> #{a := A, b := A}.

update_map3(M) ->
    A0 = M . a,
    B0 = M . a,
    M#{a := B0, b := A0}.

-spec access_map(#{id := Id, location := Location, _ := _}) ->
                    {Id, Location}.

access_map(M) ->
    {M . id, M . location}.

-spec access_map2(#{inner1 := #{inner2 := A}}) -> A.

access_map2(M) ->
    M . inner1 . inner2.

-spec mk_seq() -> {integer(), integer()}.

mk_seq() ->
    X = 1,
    Y = 2,
    {X, Y}.

-spec is_empty([_]) -> boolean().

is_empty([]) ->
    true;
is_empty([_H | _T]) ->
    false.

-spec is_empty2([_]) -> boolean().

is_empty2([]) ->
    true;
is_empty2(_) ->
    false.

-spec with_as(integer()) -> integer().

with_as(1 = X) ->
    X;
with_as(_ = Y) ->
    Y.

-spec block(A, [A]) -> {[A], [A]}.

block(X, Y) ->
    {begin
         Z = [X | Y],
         Z
     end,
     begin [X | Y] end}.

-spec is_empty_case([_]) -> boolean().

is_empty_case(L) ->
    case L of
        [] ->
            true;
        _ ->
            false
    end.

-spec both_empty([_], [_]) -> boolean().

both_empty(L1, L2) ->
    case L1 of
        [] ->
            case L2 of
                [] ->
                    true;
                _ ->
                    false
            end;
        _ ->
            false
    end.

-spec call([_], [_]) -> boolean().

call(L1, L2) ->
    mod01:both_empty(L1, L2).

-spec remote_call([A]) -> [A].

remote_call(L) ->
    ocaml_list:rev(L).

-spec fun_to_var() -> fun((A, B) -> {A, B}).

fun_to_var() ->
    F = fun(X, Y) ->
               {X, Y}
        end,
    F.

-spec local_fun_to_var(_, _) -> fun(([_], [_]) -> boolean()).

local_fun_to_var(_A, _B) ->
    F = fun call/2,
    F.

-spec remote_fun_to_var(_, _) -> fun(([A]) -> [A]).

remote_fun_to_var(_A, _B) ->
    F = fun ocaml_list:rev/1,
    F.

-spec local_n_fun() -> fun(([_]) -> [_]).

local_n_fun() ->
    F = fun Local([_ | T]) ->
                Local(T);
            Local([]) ->
                []
        end,
    F.

-spec mod01F(X) -> X.

mod01F(X) ->
    X.

-spec unary_plus(integer()) -> integer().

unary_plus(X) ->
    + (+ X).

-spec unary_minus(integer()) -> integer().

unary_minus(X) ->
    - (- X).

-spec unary_not(boolean()) -> boolean().

unary_not(X) ->
    not (not X).

-spec unary_bnot(integer()) -> integer().

unary_bnot(X) ->
    bnot (bnot X).

-spec binary_star(integer(), integer()) -> integer().

binary_star(X, Y) ->
    X * Y.

-spec binary_div(integer(), integer()) -> integer().

binary_div(X, Y) ->
    X div Y.

-spec binary_rem(integer(), integer()) -> integer().

binary_rem(X, Y) ->
    X rem Y.

-spec binary_band(integer(), integer()) -> integer().

binary_band(X, Y) ->
    X band Y.

-spec binary_and(boolean(), boolean()) -> boolean().

binary_and(X, Y) ->
    X and Y.

-spec binary_plus(integer(), integer()) -> integer().

binary_plus(X, Y) ->
    X + Y.

-spec binary_minus(integer(), integer()) -> integer().

binary_minus(X, Y) ->
    X - Y.

-spec binary_bor(integer(), integer()) -> integer().

binary_bor(X, Y) ->
    X bor Y.

-spec binary_bxor(integer(), integer()) -> integer().

binary_bxor(X, Y) ->
    X bxor Y.

-spec binary_bsl(integer(), integer()) -> integer().

binary_bsl(X, Y) ->
    X bsl Y.

-spec binary_bsr(integer(), integer()) -> integer().

binary_bsr(X, Y) ->
    X bsr Y.

-spec binary_or(boolean(), boolean()) -> boolean().

binary_or(X, Y) ->
    X or Y.

-spec binary_xor(boolean(), boolean()) -> boolean().

binary_xor(X, Y) ->
    X xor Y.

-spec binary_orelse(boolean(), boolean()) -> boolean().

binary_orelse(X, Y) ->
    X
    orelse
    Y.

-spec binary_andalso(boolean(), boolean()) -> boolean().

binary_andalso(X, Y) ->
    X
    andalso
    Y.

-spec list_plus([A], [A]) -> [A].

list_plus(X, Y) ->
    X ++ Y.

-spec list_minus([A], [A]) -> [A].

list_minus(X, Y) ->
    X -- Y.

-spec comp1(A, A) -> boolean().

comp1(X, Y) ->
    X == Y.

-spec comp2(A, A) -> boolean().

comp2(X, Y) ->
    X /= Y.

-spec comp3(A, A) -> boolean().

comp3(X, Y) ->
    X =< Y.

-spec comp4(A, A) -> boolean().

comp4(X, Y) ->
    X < Y.

-spec comp5(A, A) -> boolean().

comp5(X, Y) ->
    X >= Y.

-spec comp6(A, A) -> boolean().

comp6(X, Y) ->
    X > Y.

-spec comp7(A, A) -> boolean().

comp7(X, Y) ->
    X =:= Y.

-spec comp8(A, A) -> boolean().

comp8(X, Y) ->
    X =/= Y.

-spec guard1(integer(), integer()) -> boolean().

guard1(X, Y) when X == 1, Y == 1; X =/= Y ->
    true;
guard1(X, Y) when X > Y ->
    false;
guard1(_X, _Y) ->
    false.

-spec guard2([A], A, [A]) -> [A].

guard2(X, Y, []) ->
    case X of
        [X1 | Xs] when X1 == Y ->
            Xs;
        Xs ->
            Xs
    end;
guard2(X, _, Z) when X == Z ->
    Z;
guard2(_, _, Z) ->
    Z.

-spec p_match_tuple0({}) -> {{}}.

p_match_tuple0({}) ->
    {{}}.

-spec p_match_tuple1({_}) -> {}.

p_match_tuple1({_X}) ->
    {}.

-spec p_match_invoke() -> {}.

p_match_invoke() ->
    p_match_tuple0({}),
    p_match_tuple1({{}}).

-spec any_id(any()) -> any().

any_id(A) ->
    A.

-spec atom_id(atom()) -> atom().

atom_id(A) ->
    A.

-spec binary_id(binary()) -> binary().

binary_id(A) ->
    A.

-spec bitstring_id(bitstring()) -> bitstring().

bitstring_id(A) ->
    A.

-spec byte_id(byte()) -> byte().

byte_id(A) ->
    A.

-spec float_id(float()) -> float().

float_id(X) ->
    X.

-spec identifier_id(identifier()) -> identifier().

identifier_id(A) ->
    A.

-spec iodata_id(iodata()) -> iodata().

iodata_id(A) ->
    A.

-spec iolist_id(iolist()) -> iolist().

iolist_id(A) ->
    A.

-spec map_id(#{A => B}) -> #{A => B}.

map_id(M) ->
    M.

-spec none_id(none()) -> none().

none_id(A) ->
    A.

-spec noreturn_id(no_return()) -> no_return().

noreturn_id(A) ->
    none_id(A).

-spec number_id(none()) -> none().

number_id(A) ->
    A.

-spec pid_id(pid()) -> pid().

pid_id(A) ->
    A.

-spec port_id(port()) -> port().

port_id(A) ->
    A.

-spec reference_id(reference()) -> reference().

reference_id(A) ->
    A.

-spec term_id(term()) -> term().

term_id(A) ->
    A.

-spec timeout_id(timeout()) -> timeout().

timeout_id(A) ->
    A.

-spec ints_id({neg_integer(), non_neg_integer(), pos_integer()}) ->
                 {neg_integer(), non_neg_integer(), pos_integer()}.

ints_id(X) ->
    X.

-type my_pair2(A) :: mod01:my_pair(A, A).

-type my_pair(A, B) :: {A, B}.

-spec mk_my_pair(A, A) -> mod01:my_pair2(A).

mk_my_pair(A, B) ->
    {A, B}.



