-file("mod03.erl", 1).

-module(mod03).

-compile(export_all).

-type unit0() :: {969696, mod03, unit0}.

-type boxed(A) :: {969696, mod03, boxed, A}.

-type either(A, B) ::
          {969696, mod03, left, A} | {969696, mod03, right, B}.

-type rgb() ::
          {969696, mod03, r} | {969696, mod03, g} | {969696, mod03, b}.

-type pair(A, B) :: {969696, mod03, pair, A, B}.

-type triple(A, B, C) :: {969696, mod03, triple, A, B, C}.

-type my_list(A) ::
          {969696, mod03, cons, A, my_list(A)} | {969696, mod03, nil}.

-type option(A) :: {969696, mod03, none} | {969696, mod03, some, A}.

-spec mk_unit() -> unit0().

mk_unit() ->
    {969696, mod03, unit0}.

-spec mk_box(A) -> boxed(A).

mk_box(A) ->
    {969696, mod03, boxed, A}.

-spec mk_left(A) -> either(A, _).

mk_left(A) ->
    {969696, mod03, left, A}.

-spec mk_right(B) -> either(_, B).

mk_right(B) ->
    {969696, mod03, right, B}.

-spec zero(unit0(), V) -> V.

zero({969696, mod03, unit0}, Val) ->
    Val.

-spec unbox(boxed(E)) -> E.

unbox(Boxed) ->
    case Boxed of
        {969696, mod03, boxed, Elem} ->
            Elem
    end.

-spec un_either(either(A, A)) -> A.

un_either(Either) ->
    case Either of
        {969696, mod03, left, Elem} ->
            Elem;
        {969696, mod03, right, Elem} ->
            Elem
    end.

-spec un_pair(pair(A, B)) -> {A, B}.

un_pair(Pair) ->
    case Pair of
        {969696, mod03, pair, A, B} ->
            {A, B}
    end.

-spec first(pair(A, _)) -> A.

first({969696, mod03, pair, F, _}) ->
    F.

-spec second(pair(_, B)) -> B.

second({969696, mod03, pair, _, S}) ->
    S.



