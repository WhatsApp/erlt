DIRS := calc dev dev_enum dev_struct doc elm_core erltodo

build: $(if $(ERLTCI),build-ci,build-dev) 
	echo "env var ERLTCI is set to $(ERLTCI)"

build-dev: build-sterlang-jar
	@# the dependency above on build-sterlang-jar isn't strictly necessary (since we use the daemon),
	@# but is helpful if you later want to use the rebar shell or run erltc directly

	../scripts/dl-sbtn.sh
	cd ../sterlang && ../scripts/sbtn sterlangd
	ERL_FLAGS="-args_file dev.vm.args" ../scripts/rebar3 compile

build-ci:
	../scripts/rebar3 compile

 # we depend on `clean` because that will force rebar to copy over the priv dir containing
 # sterlang.jar
build-sterlang-jar: clean
	make -C ../sterlang

# test using sterlang jar file. This is a good balance for erltc CI on each push
# because it is closer what the users will use than sterlangd (daemon) and not as slow to build as a native binary
test-jar: build-sterlang-jar
	@# call self with ERLTCI env var set to true: in the `build` step we use this env var
	ERLTCI=true make -C . test

# test using a native sterlang binary. This is ideal for our release ci, where correctness is more important than speed
test-native: clean
	@test -f ../erltc/priv/sterlang || (echo "sterlang native binary is required, see <repo>/examples/README.md" && $$(exit 2))
	rm -f ../erltc/priv/sterlang.jar
	@# call self with ERLTCI env var set to true: in the `build` step we use this env var
	ERLTCI=true make -C . test

clean:
	rm -rf _build
	find . -name "*.els" -delete || true

test-ir: $(DIRS:%=test-ir/%)

clean-ir:
	find _build -name build -delete || true

test-beam: $(DIRS:%=test-beam/%)

ir: clean-ir build

# The generated .erl files are not actually used in compilation
# but are there for humans to read. Not actually "ir"
test-ir/%: ir
	@# only include .erl files
	diff -r -x sterlang -x '*.defs' -x '*.etf' -x '*.D' -x '*.els' _build/default/lib/$*/build $*/ir-spec

# test `erlt --------> beam -> disassembly`
# matches `erlt -> erl -> beam -> disassembly`
test-beam/%: ir
	rm -rf _build/default/lib/$*/test_ouptput
	mkdir -p _build/default/lib/$*/test_output/from_erl
	mkdir -p _build/default/lib/$*/test_output/from_beam
	../test_util/disassemble.escript --beam _build/default/lib/$*/ebin _build/default/lib/$*/test_output/from_beam
	@# this is annoying hard-coding, but we need to exclude files generated by rebar's classic erlang and yrl+xrl compilers
	@# because they won't have corresponding .erls in the build directory. We'll need to do the same for beams generated from .erls in future
	@# Note: we ignore t_* files because these come from the built-ins (see ../erltc/built_ins/README.md
	rm -f _build/default/lib/$*/test_output/from_beam/*_lexer.dis _build/default/lib/$*/test_output/from_beam/*_parser.dis
	../test_util/disassemble.escript --erl _build/default/lib/$*/build _build/default/lib/$*/test_output/from_erl
	diff -r _build/default/lib/$*/test_output/from_beam _build/default/lib/$*/test_output/from_erl -x t_*

update-ir-spec/%: ir
	@rm -rf $*/ir-spec
	@mkdir $*/ir-spec
	cp _build/default/lib/$*/build/*.erl $*/ir-spec

update-ir-spec: $(DIRS:%=update-ir-spec/%)

test-others:
	# TODO: port to remote structs and re-enable
	# $(MAKE) -C dev_module_record/src erl2c-records
	$(MAKE) -C checks/src test

test-interop: build
	# test that we are not removing beams generated from classic rebar compilers
	@stat _build/default/lib/calc/ebin/calc_lexer.beam &> /dev/null
	@stat _build/default/lib/calc/ebin/calc_parser.beam &> /dev/null && echo ok

test: test-ir test-beam test-interop test-others

.PHONY: build build-ci build-dev build-sterlang-jar clean ir update-ir-spec \
		test-native test-jar test-beam test-interop test-ir 
