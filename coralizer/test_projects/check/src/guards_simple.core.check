-module(guards_simple)
-exports(atom_neg_1/1, atom_neg_2/1, atom_neg_3/1, atom_pos_1/1, atom_pos_2/1, atom_pos_3/1, boolean_neg_1/1, boolean_neg_2/1, boolean_neg_3/1, boolean_pos_1/1, boolean_pos_2/1, boolean_pos_3/1, float_neg/1, float_pos/1, integer_neg/1, integer_pos/1, module_info/0, module_info/1, pid_neg/1, pid_pos/1, port_neg/1, port_pos/1, reference_neg/1, reference_pos/1)
-file([({guards_simple.erl 1})])
-compile([(export_all nowarn_export_all)])

:: fun((term()) -> atom())
atom_pos_1/1 = fun (var0)  { 
    case var0 of {  X when erlang:is_atom(X) -> X
    }
}

:: fun((term()) -> atom())
atom_pos_2/1 = fun (var0)  { 
    case var0 of { 
        X when true -> case <> of { 
                 when erlang:is_atom(X) -> X
            }
    }
}

:: fun((term()) -> atom())
atom_pos_3/1 = fun (var0)  { 
    case var0 of { 
        X when true -> case X of { 
                Y when erlang:is_atom(Y) -> Y
            }
    }
}

:: fun((term()) -> atom())
atom_neg_1/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_number(X) -> X                      | X. Expected: atom(), Got: number()
    }
}

:: fun((term()) -> atom())
atom_neg_2/1 = fun (var0)  { 
    case var0 of { 
        X when true -> case <> of { 
                 when erlang:is_list(X) -> X                 | X. Expected: atom(), Got: term()
            }
    }
}

:: fun((term()) -> atom())
atom_neg_3/1 = fun (var0)  { 
    case var0 of { 
        X when true -> case X of { 
                Y when erlang:is_tuple(Y) -> Y               | Y. Expected: atom(), Got: term()
            }
    }
}

:: fun((term()) -> 'false' | 'true')
boolean_pos_1/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_boolean(X) -> X
    }
}

:: fun((term()) -> 'false' | 'true')
boolean_pos_2/1 = fun (var0)  { 
    case var0 of { 
        X when true -> case <> of { 
                 when erlang:is_boolean(X) -> X
            }
    }
}

:: fun((term()) -> 'false' | 'true')
boolean_pos_3/1 = fun (var0)  { 
    case var0 of { 
        X when true -> case X of { 
                Y when erlang:is_boolean(Y) -> Y
            }
    }
}

:: fun((term()) -> 'false' | 'true')
boolean_neg_1/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_atom(X) -> X                        | X. Expected: 'false' | 'true', Got: atom()
    }
}

:: fun((term()) -> 'false' | 'true')
boolean_neg_2/1 = fun (var0)  { 
    case var0 of { 
        X when true -> case <> of { 
                 when erlang:is_atom(X) -> X                 | X. Expected: 'false' | 'true', Got: atom()
            }
    }
}

:: fun((term()) -> 'false' | 'true')
boolean_neg_3/1 = fun (var0)  { 
    case var0 of { 
        X when true -> case X of { 
                Y when erlang:is_atom(Y) -> Y                | Y. Expected: 'false' | 'true', Got: atom()
            }
    }
}

:: fun((term()) -> number())
float_pos/1 = fun (var0)  { 
    case var0 of {  X when erlang:is_float(X) -> X
    }
}

:: fun((term()) -> number())
float_neg/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_boolean(X) -> X                     | X. Expected: number(), Got: 'false' | 'true'
    }
}

:: fun((term()) -> number())
integer_pos/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_integer(X) -> X
    }
}

:: fun((term()) -> number())
integer_neg/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_boolean(X) -> X                     | X. Expected: number(), Got: 'false' | 'true'
    }
}

:: fun((term()) -> pid())
pid_pos/1 = fun (var0)  { 
    case var0 of {  X when erlang:is_pid(X) -> X }
}

:: fun((term()) -> pid())
pid_neg/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_number(X) -> X                      | X. Expected: pid(), Got: number()
    }
}

:: fun((term()) -> port())
port_pos/1 = fun (var0)  { 
    case var0 of {  X when erlang:is_port(X) -> X
    }
}

:: fun((term()) -> pid())
port_neg/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_reference(X) -> X                   | X. Expected: pid(), Got: reference()
    }
}

:: fun((term()) -> port())
reference_pos/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_reference(X) -> X                   | X. Expected: port(), Got: reference()
    }
}

:: fun((term()) -> pid())
reference_neg/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_port(X) -> X                        | X. Expected: pid(), Got: port()
    }
}

module_info/0 = fun ()  { 
    case <> of { 
         when true -> erlang:get_module_info(guards_simple)
    }
}

module_info/1 = fun (var0)  { 
    case var0 of { 
        X when true -> erlang:get_module_info(guards_simple, X)
    }
}
