-module(misc).
-exports module_info/0, module_info/1, test01/1, test02/1, test03_neg/1, test04_neg/1, test05_neg/1, test06_neg/1, test07/1, test08_neg/1, test09/2, test10_neg/2, test11_neg/2, test12_neg/1, test13_neg/2, test14/2, test15/2, test16_neg/2, test17_neg/2, test18_neg/2, test19_neg/2, test20_neg/1, test21_neg/2, test22_neg/1, test23_neg/2, test24_neg/2, test25_pos/1, test26_pos/1, test27_pos/1, test28_neg/1, test29_neg/0, test30_neg/0, test31_neg/0, test32_neg/0, test33_pos/2, test34_pos/2, test35_pos/2, test36_pos/2, test37_pos/2, test38_pos/1, test39_pos/1, test40_pos/1, test41_pos/1, test42_pos/1, test43_pos/1, test44_neg/1, test45_neg/1, test46_neg/0, test47_neg/0, test48_neg/0, test49_neg/0, test50_pos/0, test51_pos/0, test52_pos/0, test53_pos/0, test54_unspecced/0, test55_neg/0, test56_neg/0, test57_pos/0, test58_pos/3, test59_pos/0, test60_pos/0, test61_neg/0, test62_neg/0, test63_pos/0, test64_pos/0, test65_pos/0, test66_pos/0, test67_pos/2, test68_pos/1, test69_pos/1, test70_neg/0, test71_neg/0, test72_neg/0, test73_pos/0, test74_pos/0, test75_pos/0, test76_pos/1, test77_neg/1.
-file([({/Users/mheiber/erlt/coralizer/test_projects/check/src/misc.erl 1})])
-compile([(export_all nowarn_export_all)])

test70_neg/0 = fun ()  { 
    case <> of { 
         when true -> catch test69_pos/1([atom | [()]])      | catch .... Expected: [atom() | number()], Got: term()
    }
}

test26_pos/1 = fun (var0)  { 
    case var0 of {  X when true -> X }
}

test02/1 = fun (var0)  { 
    case var0 of {  Y=2.0 when true -> Y }
}

test54_unspecced/0 = fun ()  { 
    case <> of {   when true -> ok }
}

test16_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> erlang:or(X, Y)                     | 'erlang':'or'(X,Y). Expected: number(), Got: 'false' | 'true'
    }
}

test33_pos/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        AB BC when true -> case AB of { 
                var5 when erlang:=:=(var5, BC) -> BC         | BC. Expected: 'b', Got: 'b' | 'c'
            }
    }
}

module_info/1 = fun (var0)  { 
    case var0 of { 
        X when true -> erlang:get_module_info(misc, X)
    }
}

test69_pos/1 = fun (var0)  { 
    case var0 of {  [H | T] when true -> [H | T] }
}

test41_pos/1 = fun (var0)  { 
    case var0 of {  [X | Y] when true -> {X, Y} }
}

test53_pos/0 = fun ()  { 
    case <> of { 
         when true -> erlang:make_fun(misc, test47_neg, 0)
    }
}

test05_neg/1 = fun (var0)  { 
    case var0 of {  X when true -> erlang:+(X) }
}

test72_neg/0 = fun ()  { 
    case <> of { 
         when true -> catch test69_pos/1(atom)
    }
}

test20_neg/1 = fun (var0)  { 
    case var0 of { 
        X when true -> let var1 = erlang:-(X) in {           | let .... Expected: [atom()], Got: [number()]
                [var1 | [()]]
            }
    }
}

test31_neg/0 = fun ()  { 
    case <> of { 
         when true -> test30_neg/0                           | test30_neg/0. Expected: 'atom', Got: fun(() -> 'atom')
    }
}

test13_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> erlang:or(X, Y)
    }
}

test76_pos/1 = fun (var0)  { 
    case var0 of { 
        A when erlang:is_atom(A) -> A
        var2 when true -> erlang:throw({error, not_an_atom})
    }
}

test75_pos/0 = fun ()  { 
    case <> of { 
         when true -> letrec (after$^0/0 = fun ()  { 
                    case <> of { 
                         when true -> nook
                    }
                }) in  { 
                try try ok of  { 
                        var0 -> case var0 of { 
                            ok when true -> ok
                        }
                    }
                    catch {
                        var4, var3, var2 -> case {var4, var3, var2} of { 
                            
                        }
                    }
                     of  { 
                    var5 -> after$^0/0() , var5
                }
                catch {
                    var8, var7, var6 -> case {var8, var7, var6} of { 
                        {var8, var7, var6} when true ->
                        after$^0/0() , primop:raise(var6, var7)
                    }
                }
                
            }
    }
}

test50_pos/0 = fun ()  { 
    case <> of {   when true -> misc:test47_neg()
    }
}

test52_pos/0 = fun ()  { 
    case <> of {   when true -> test47_neg/0 }
}

test35_pos/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        AB BC when true -> case AB of { 
                var5 when erlang:=:=(var5, BC) -> BC         | BC. Expected: ['b'], Got: ['b' | 'c']
            }
    }
}

test07/1 = fun (var0)  { 
    case var0 of {  X when true -> erlang:not(X) }
}

test62_neg/0 = fun ()  { 
    case <> of { 
         when true -> let X = test54_unspecced/0() in {      | Unbound var: test54_unspecced/0
                X
            }
    }
}

test30_neg/0 = fun ()  { 
    case <> of {   when true -> 1 }                          | 1. Expected: 'atom', Got: number()
}

test46_neg/0 = fun ()  { 
    case <> of {   when true -> false }                      | 'false'. Expected: number(), Got: 'false'
}

test34_pos/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        AB BC when true -> case AB of { 
                var5 when erlang:=:=(var5, BC) -> BC         | BC. Expected: {'b'}, Got: {'b' | 'c'}
            }
    }
}

test55_neg/0 = fun ()  { 
    case <> of { 
         when true -> erlang:make_fun(misc, test54_unspecced, 0) | Unbound var: misc:test54_unspecced/0
    }
}

test14/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> case X of { 
                true when true -> true
                false when true -> Y
                var2 when true -> erlang:error({badarg, var2})
            }
    }
}

test61_neg/0 = fun ()  { 
    case <> of { 
         when true -> let X = misc:test54_unspecced() in {   | Unbound var: misc:test54_unspecced/0
                X
            }
    }
}

test63_pos/0 = fun ()  { 
    case <> of { 
         when true -> let Fun = erlang:make_fun(misc, test47_neg, 0) in { 
                Fun
            }
    }
}

test03_neg/1 = fun (var0)  { 
    case var0 of {  X=-4 when true -> X }                    | X. Expected: atom(), Got: number()
}

test60_pos/0 = fun ()  { 
    case <> of { 
         when true -> let X = test47_neg/0() in { 
                X
            }
    }
}

test27_pos/1 = fun (var0)  { 
    case var0 of {  X when true -> [X | [()]] }
}

test73_pos/0 = fun ()  { 
    case <> of { 
         when true -> catch test69_pos/1([atom | [()]])
    }
}

test08_neg/1 = fun (var0)  { 
    case var0 of { 
        X when true -> erlang:not(X)                         | 'erlang':'not'(X). Expected: number(), Got: 'false' | 'true'
    }
}

test17_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> erlang:or(X, Y)
    }
}

test42_pos/1 = fun (var0)  { 
    case var0 of {  [X | Y] when true -> {X, Y} }
}

test10_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when erlang:is_number(X) -> erlang:+(X, Y)
    }
}

test43_pos/1 = fun (var0)  { 
    case var0 of { 
        [var3 | Y] when try let var1 = erlang:+(Y, 1) in { 
                erlang:>(var1, 0)
            } of  {  Try -> Try }
        catch {
            T, R -> false
        }
         -> Y
    }
}

test74_pos/0 = fun ()  { 
    case <> of { 
         when true -> let var0 = catch test69_pos/1([atom | [()]]) in { 
                let X = var0 in {  X }
            }
    }
}

test09/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when try let var2 = erlang:is_number(X) in { 
                let var3 = erlang:is_number(Y) in { 
                    erlang:and(var2, var3)
                }
            } of  {  Try -> Try }
        catch {
            T, R -> false
        }
         -> erlang:+(X, Y)
    }
}

test47_neg/0 = fun ()  { 
    case <> of {   when true -> [()] }                       | []. Expected: number(), Got: []
}

test25_pos/1 = fun (var0)  { 
    case var0 of { 
        [()] when true -> undefined
        [X | [()]] when true -> X
        [var2 | T] when true -> test25_pos/1(T)
    }
}

test15/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> case X of { 
                true when true -> Y
                false when true -> false
                var2 when true -> erlang:error({badarg, var2})
            }
    }
}

test18_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> case X of { 
                true when true -> true                       | 'true'. Expected: number(), Got: 'true'
                false when true -> Y
                var2 when true -> erlang:error({badarg, var2})
            }
    }
}

test58_pos/3 = fun (var0, var1, var2)  { 
    case <var0, var1, var2> of { 
        B A N when true -> let var3 = case <> of { 
                 when erlang:=:=(B, true) -> A
                 when true -> N
            } in {  let Res = var3 in {  Res } }
    }
}

test49_neg/0 = fun ()  { 
    case <> of { 
         when true -> misc:test47_neg()                      | 'misc':'test47_neg'(). Expected: atom(), Got: number()
    }
}

test68_pos/1 = fun (var0)  { 
    case var0 of {  {E, var2} when true -> E }
}

test22_neg/1 = fun (var0)  { 
    case var0 of { 
        X when true -> let var1 = erlang:not(X) in {         | let .... Expected: [number()], Got: ['false' | 'true']
                [var1 | [()]]
            }
    }
}

test01/1 = fun (var0)  { 
    case var0 of {  X=-4 when true -> X }
}

test37_pos/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when try let var2 = erlang:+(X, Y) in { 
                erlang:>(var2, 0)
            } of  {  Try -> Try }
        catch {
            T, R -> false
        }
         -> {X, Y}
    }
}

module_info/0 = fun ()  { 
    case <> of { 
         when true -> erlang:get_module_info(misc)
    }
}

test28_neg/1 = fun (var0)  { 
    case var0 of { 
        B when true -> misc_lib:boolean_id(B)
    }
}

test45_neg/1 = fun (var0)  { 
    case var0 of { 
        X when true -> let var6, Z = case X of { 
                var4 when true -> let Z = ok in { 
                        <Z, Z>
                    }
                var2 when true -> let var5 = primop:match_fail({case_clause, var2}) in { 
                        <var5, [()]>
                    }
            } in {  Z }
    }
}

test44_neg/1 = fun (var0)  { 
    case var0 of { 
        X when true -> let var4, Z = case X of { 
                Z when true -> <ok, Z>
                var1 when true -> let var3 = primop:match_fail({case_clause, var1}) in { 
                        <var3, [()]>
                    }
            } in {  Z }
    }
}

test19_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> case X of { 
                true when true -> Y                          | Y. Expected: {number()}, Got: number()
                false when true -> false
                var2 when true -> erlang:error({badarg, var2})
            }
    }
}

test65_pos/0 = fun ()  { 
    case <> of { 
         when true -> let L = [()] in {  L }
    }
}

test38_pos/1 = fun (var0)  { 
    case var0 of { 
        X when try let var1 = erlang:bnot(X) in { 
                erlang:>(var1, 0)
            } of  {  Try -> Try }
        catch {
            T, R -> false
        }
         -> {X}                                              | {X}. Expected: {number()}, Got: {term()}
    }
}

test23_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> let var2 = erlang:or(X, Y) in {     | let .... Expected: [number()], Got: ['false' | 'true']
                [var2 | [()]]
            }
    }
}

test36_pos/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        F1 F2 when true -> case F1 of { 
                var5 when erlang:=:=(var5, F2) -> F2         | F2. Expected: fun(('a' | 'b') -> 'z'), Got: fun(('b') -> 'b' | 'z')
            }
    }
}

test40_pos/1 = fun (var0)  { 
    case var0 of {  {X, Y} when true -> {X, Y} }
}

test67_pos/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        A N when true -> let Head = A in { 
                let Tail = [N | [()]] in { 
                    let Result = [Head | Tail] in { 
                        Result
                    }
                }
            }
    }
}

test32_neg/0 = fun ()  { 
    case <> of { 
         when true -> erlang:make_fun(misc_lib, boolean_id, 1) | 'erlang':'make_fun'('misc_lib','boolean_id',1). Expected: 'atom', Got: fun(('false' | 'true') -> 'false' | 'true')
    }
}

test57_pos/0 = fun ()  { 
    case <> of { 
         when true -> let A = atom in { 
                let N = 1 in {  {A, N} }
            }
    }
}

test77_neg/1 = fun (var0)  { 
    case var0 of { 
        A when true -> catch test76_pos/1(A)                 | catch .... Expected: atom(), Got: term()
    }
}

test39_pos/1 = fun (var0)  { 
    case var0 of { 
        {X, Y} when true -> {X, Y}
        var2 when true -> {a, b}
    }
}

test04_neg/1 = fun (var0)  { 
    case var0 of {  Y=2.0 when true -> Y }                   | Y. Expected: atom(), Got: number()
}

test12_neg/1 = fun (var0)  { 
    case var0 of {  X when true -> erlang:-(X) }
}

test11_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> erlang:+(X, Y)                      | 'erlang':'+'(X,Y). Expected: atom(), Got: number()
    }
}

test29_neg/0 = fun ()  { 
    case <> of { 
         when true -> [true | [false | [()]]]                | ['true' | ['false' | []]]. Expected: [], Got: ['true' | 'false']
    }
}

test51_pos/0 = fun ()  { 
    case <> of {   when true -> test47_neg/0() }
}

test64_pos/0 = fun ()  { 
    case <> of { 
         when true -> let var0 = test47_neg/0 in { 
                let Fun = var0 in {  Fun }
            }
    }
}

test71_neg/0 = fun ()  { 
    case <> of { 
         when true -> catch test69_pos/1(atom)
    }
}

test21_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> let var2 = erlang:/(X, Y) in {      | let .... Expected: [atom()], Got: [number()]
                [var2 | [()]]
            }
    }
}

test48_neg/0 = fun ()  { 
    case <> of { 
         when true -> test47_neg/0()                         | test47_neg/0(). Expected: atom(), Got: number()
    }
}

test59_pos/0 = fun ()  { 
    case <> of { 
         when true -> let X = misc:test47_neg() in { 
                X
            }
    }
}

test24_neg/2 = fun (var0, var1)  { 
    case <var0, var1> of { 
        X Y when true -> let var4 = case X of {              | let .... Expected: [number()], Got: [atom()]
                true when true -> true
                false when true -> Y
                var2 when true -> erlang:error({badarg, var2})
            } in {  [var4 | [()]] }
    }
}

test56_neg/0 = fun ()  { 
    case <> of { 
         when true -> test54_unspecced/0                     | Unbound var: test54_unspecced/0
    }
}

test66_pos/0 = fun ()  { 
    case <> of { 
         when true -> let X = a in { 
                let Y = 1 in { 
                    let Result = {X, Y} in { 
                        Result
                    }
                }
            }
    }
}

test06_neg/1 = fun (var0)  { 
    case var0 of { 
        X when erlang:is_number(X) -> erlang:+(X)            | 'erlang':'+'(X). Expected: atom(), Got: number()
    }
}
