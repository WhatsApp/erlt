-module(misc)
-exports(module_info/0, module_info/1, test01/1, test02/1, test03_neg/1, test04_neg/1, test05_neg/1, test06_neg/1, test07/1, test08_neg/1, test09/2, test10_neg/2, test11_neg/2, test12_neg/1, test13_neg/2, test14/2, test15/2, test16_neg/2, test17_neg/2, test18_neg/2, test19_neg/2, test20_neg/1, test21_neg/2, test22_neg/1, test23_neg/2, test24_neg/2, test25_pos/1, test26_pos/1, test27_pos/1, test28_neg/1, test29_neg/0, test30_neg/0, test31_neg/0, test32_neg/0, test33_pos/2, test34_pos/2, test35_pos/2, test36_pos/2, test37_pos/2, test38_pos/1, test39_pos/1, test40_pos/1, test41_pos/1, test42_pos/1, test43_pos/1, test44_neg/1, test45_neg/1, test46_neg/0, test47_neg/0, test48_neg/0, test49_neg/0, test50_pos/0, test51_pos/0, test52_pos/0, test53_pos/0, test54_unspecced/0, test55_neg/0, test56_neg/0, test57_pos/0, test58_pos/3, test59_pos/0, test60_pos/0, test61_neg/0, test62_neg/0, test63_pos/0, test64_pos/0, test65_pos/0, test66_pos/0, test67_pos/2, test68_pos/1, test69_pos/1, test70_neg/0, test71_neg/0, test72_neg/0, test73_pos/0, test74_pos/0, test75_pos/0, test76_pos/1, test77_neg/1)
-file([{misc.erl 1}])
-compile([export_all nowarn_export_all])

:: fun((term()) -> number())
test01/1 = fun (var0) { 
    case var0 of {  X=-4 when true -> X }
}

:: fun((term()) -> number())
test02/1 = fun (var0) { 
    case var0 of {  Y=2.0 when true -> Y }
}

:: fun((term()) -> atom())
test03_neg/1 = fun (var0) { 
    case var0 of {  X=-4 when true -> X }                    | X. Expected: atom(), Got: number()
}

:: fun((term()) -> atom())
test04_neg/1 = fun (var0) { 
    case var0 of {  Y=2.0 when true -> Y }                   | Y. Expected: atom(), Got: number()
}

:: fun((term()) -> term())
test05_neg/1 = fun (var0) { 
    case var0 of {  X when true -> erlang:+(X) }
}

:: fun((term()) -> atom())
test06_neg/1 = fun (var0) { 
    case var0 of { 
        X when erlang:is_number(X) -> erlang:+(X)            | 'erlang':'+'(X). Expected: atom(), Got: number()
    }
}

:: fun(('false' | 'true') -> atom())
test07/1 = fun (var0) { 
    case var0 of {  X when true -> erlang:not(X) }
}

:: fun(('false' | 'true') -> number())
test08_neg/1 = fun (var0) { 
    case var0 of { 
        X when true -> erlang:not(X)                         | 'erlang':'not'(X). Expected: number(), Got: 'false' | 'true'
    }
}

:: fun((term(), term()) -> number())
test09/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when try let var2 = erlang:is_number(X) in { 
                let var3 = erlang:is_number(Y) in { 
                    erlang:and(var2, var3)
                }
            } of {  Try -> Try }
        catch {
            T, R -> false
        }
         -> erlang:+(X, Y)
    }
}

:: fun((term(), term()) -> number())
test10_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when erlang:is_number(X) -> erlang:+(X, Y)
    }
}

:: fun((number(), number()) -> atom())
test11_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> erlang:+(X, Y)                   | 'erlang':'+'(X,Y). Expected: atom(), Got: number()
    }
}

:: fun((atom()) -> number())
test12_neg/1 = fun (var0) { 
    case var0 of {  X when true -> erlang:-(X) }
}

:: fun((term(), term()) -> 'false' | 'true')
test13_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> erlang:or(X, Y)
    }
}

:: fun(('false' | 'true', atom()) -> atom())
test14/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> case X of { 
                true when true -> true
                false when true -> Y
                var2 when true -> erlang:error({badarg, var2})
            }
    }
}

:: fun(('false' | 'true', atom()) -> atom())
test15/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> case X of { 
                true when true -> Y
                false when true -> false
                var2 when true -> erlang:error({badarg, var2})
            }
    }
}

:: fun(('false' | 'true', 'false' | 'true') -> number())
test16_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> erlang:or(X, Y)                  | 'erlang':'or'(X,Y). Expected: number(), Got: 'false' | 'true'
    }
}

:: fun(('false' | 'true', atom()) -> 'false' | 'true')
test17_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> erlang:or(X, Y)
    }
}

:: fun(('false' | 'true', atom()) -> number())
test18_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> case X of { 
                true when true -> true                       | 'true'. Expected: number(), Got: 'true'
                false when true -> Y
                var2 when true -> erlang:error({badarg, var2})
            }
    }
}

:: fun(('false' | 'true', number()) -> {number()})
test19_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> case X of { 
                true when true -> Y                          | Y. Expected: {number()}, Got: number()
                false when true -> false
                var2 when true -> erlang:error({badarg, var2})
            }
    }
}

:: fun((number()) -> [atom()])
test20_neg/1 = fun (var0) { 
    case var0 of { 
        X when true -> let var1 = erlang:-(X) in {           | let .... Expected: [atom()], Got: [number()]
                [var1 | []]
            }
    }
}

:: fun((number(), number()) -> [atom()])
test21_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> let var2 = erlang:/(X, Y) in {   | let .... Expected: [atom()], Got: [number()]
                [var2 | []]
            }
    }
}

:: fun(('false' | 'true') -> [number()])
test22_neg/1 = fun (var0) { 
    case var0 of { 
        X when true -> let var1 = erlang:not(X) in {         | let .... Expected: [number()], Got: ['false' | 'true']
                [var1 | []]
            }
    }
}

:: fun(('false' | 'true', 'false' | 'true') -> [number()])
test23_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> let var2 = erlang:or(X, Y) in {  | let .... Expected: [number()], Got: ['false' | 'true']
                [var2 | []]
            }
    }
}

:: fun(('false' | 'true', atom()) -> [number()])
test24_neg/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when true -> let var4 = case X of {           | let .... Expected: [number()], Got: [atom()]
                true when true -> true
                false when true -> Y
                var2 when true -> erlang:error({badarg, var2})
            } in {  [var4 | []] }
    }
}

:: fun((['false' | 'true']) -> 'false' | 'true' | 'undefined')
test25_pos/1 = fun (var0) { 
    case var0 of { 
        [] when true -> undefined
        [X | []] when true -> X
        [var2 | T] when true -> test25_pos/1(T)
    }
}

:: fun((X) -> X)
test26_pos/1 = fun (var0) { 
    case var0 of {  X when true -> X }
}

:: fun((X) -> [X])
test27_pos/1 = fun (var0) { 
    case var0 of {  X when true -> [X | []] }
}

:: fun((atom()) -> 'false' | 'true')
test28_neg/1 = fun (var0) { 
    case var0 of { 
        B when true -> misc_lib:boolean_id(B)
    }
}

:: fun(() -> [])
test29_neg/0 = fun () { 
    case <> of { 
        <> when true -> [true | [false | []]]                | ['true' | ['false' | []]]. Expected: [], Got: ['true' | 'false']
    }
}

:: fun(() -> 'atom')
test30_neg/0 = fun () { 
    case <> of {  <> when true -> 1 }                        | 1. Expected: 'atom', Got: number()
}

:: fun(() -> 'atom')
test31_neg/0 = fun () { 
    case <> of { 
        <> when true -> test30_neg/0                         | test30_neg/0. Expected: 'atom', Got: fun(() -> 'atom')
    }
}

:: fun(() -> 'atom')
test32_neg/0 = fun () { 
    case <> of { 
        <> when true -> erlang:make_fun(misc_lib, boolean_id, 1) | 'erlang':'make_fun'('misc_lib','boolean_id',1). Expected: 'atom', Got: fun(('false' | 'true') -> 'false' | 'true')
    }
}

:: fun(('a' | 'b', 'b' | 'c') -> 'b')
test33_pos/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <AB, BC> when true -> case AB of { 
                var5 when erlang:=:=(var5, BC) -> BC         | BC. Expected: 'b', Got: 'b' | 'c'
            }
    }
}

:: fun(({'a' | 'b'}, {'b' | 'c'}) -> {'b'})
test34_pos/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <AB, BC> when true -> case AB of { 
                var5 when erlang:=:=(var5, BC) -> BC         | BC. Expected: {'b'}, Got: {'b' | 'c'}
            }
    }
}

:: fun((['a' | 'b'], ['b' | 'c']) -> ['b'])
test35_pos/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <AB, BC> when true -> case AB of { 
                var5 when erlang:=:=(var5, BC) -> BC         | BC. Expected: ['b'], Got: ['b' | 'c']
            }
    }
}

:: fun((F1, F2) -> F3)
test36_pos/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <F1, F2> when true -> case F1 of { 
                var5 when erlang:=:=(var5, F2) -> F2         | F2. Expected: fun(('a' | 'b') -> 'z'), Got: fun(('b') -> 'b' | 'z')
            }
    }
}

:: fun((term(), term()) -> {number(), number()})
test37_pos/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <X, Y> when try let var2 = erlang:+(X, Y) in { 
                erlang:>(var2, 0)
            } of {  Try -> Try }
        catch {
            T, R -> false
        }
         -> {X, Y}
    }
}

:: fun((term()) -> {number()})
test38_pos/1 = fun (var0) { 
    case var0 of { 
        X when try let var1 = erlang:bnot(X) in { 
                erlang:>(var1, 0)
            } of {  Try -> Try }
        catch {
            T, R -> false
        }
         -> {X}                                              | {X}. Expected: {number()}, Got: {term()}
    }
}

:: fun(({atom(), atom()} | number()) -> {atom(), atom()})
test39_pos/1 = fun (var0) { 
    case var0 of { 
        {X, Y} when true -> {X, Y}
        var2 when true -> {a, b}
    }
}

:: fun((number()) -> {none(), none()})
test40_pos/1 = fun (var0) { 
    case var0 of {  {X, Y} when true -> {X, Y} }
}

:: fun((number()) -> {none(), [none()]})
test41_pos/1 = fun (var0) { 
    case var0 of {  [X | Y] when true -> {X, Y} }
}

:: fun((term()) -> {term(), [term()]})
test42_pos/1 = fun (var0) { 
    case var0 of {  [X | Y] when true -> {X, Y} }
}

:: fun((term()) -> none())
test43_pos/1 = fun (var0) { 
    case var0 of { 
        [var3 | Y] when try let var1 = erlang:+(Y, 1) in { 
                erlang:>(var1, 0)
            } of {  Try -> Try }
        catch {
            T, R -> false
        }
         -> Y
    }
}

:: fun((term()) -> term())
test44_neg/1 = fun (var0) { 
    case var0 of { 
        X when true -> let var4, Z = case X of { 
                Z when true -> <ok, Z>
                var1 when true -> let var3 = primop:match_fail({case_clause, var1}) in { 
                        <var3, []>
                    }
            } in {  Z }
    }
}

:: fun((term()) -> atom())
test45_neg/1 = fun (var0) { 
    case var0 of { 
        X when true -> let var6, Z = case X of { 
                var4 when true -> let Z = ok in { 
                        <Z, Z>
                    }
                var2 when true -> let var5 = primop:match_fail({case_clause, var2}) in { 
                        <var5, []>
                    }
            } in {  Z }
    }
}

:: fun(() -> number())
test46_neg/0 = fun () { 
    case <> of {  <> when true -> false }                    | 'false'. Expected: number(), Got: 'false'
}

:: fun(() -> number())
test47_neg/0 = fun () { 
    case <> of {  <> when true -> [] }                       | []. Expected: number(), Got: []
}

:: fun(() -> atom())
test48_neg/0 = fun () { 
    case <> of { 
        <> when true -> test47_neg/0()                       | test47_neg/0(). Expected: atom(), Got: number()
    }
}

:: fun(() -> atom())
test49_neg/0 = fun () { 
    case <> of { 
        <> when true -> misc:test47_neg()                    | 'misc':'test47_neg'(). Expected: atom(), Got: number()
    }
}

:: fun(() -> number())
test50_pos/0 = fun () { 
    case <> of { 
        <> when true -> misc:test47_neg()
    }
}

:: fun(() -> number())
test51_pos/0 = fun () { 
    case <> of {  <> when true -> test47_neg/0() }
}

:: fun(() -> fun(() -> number()))
test52_pos/0 = fun () { 
    case <> of {  <> when true -> test47_neg/0 }
}

:: fun(() -> fun(() -> number()))
test53_pos/0 = fun () { 
    case <> of { 
        <> when true -> erlang:make_fun(misc, test47_neg, 0)
    }
}

test54_unspecced/0 = fun () { 
    case <> of {  <> when true -> ok }
}

:: fun(() -> fun(() -> number()))
test55_neg/0 = fun () { 
    case <> of { 
        <> when true -> erlang:make_fun(misc, test54_unspecced, 0) | Unbound var: misc:test54_unspecced/0
    }
}

:: fun(() -> fun(() -> number()))
test56_neg/0 = fun () { 
    case <> of { 
        <> when true -> test54_unspecced/0                   | Unbound var: test54_unspecced/0
    }
}

:: fun(() -> {atom(), number()})
test57_pos/0 = fun () { 
    case <> of { 
        <> when true -> let A = atom in { 
                let N = 1 in {  {A, N} }
            }
    }
}

:: fun(('false' | 'true', atom(), number()) -> atom() | number())
test58_pos/3 = fun (var0, var1, var2) { 
    case <var0, var1, var2> of { 
        <B, A, N> when true -> let var3 = case <> of { 
                <> when erlang:=:=(B, true) -> A
                <> when true -> N
            } in {  let Res = var3 in {  Res } }
    }
}

:: fun(() -> number())
test59_pos/0 = fun () { 
    case <> of { 
        <> when true -> let X = misc:test47_neg() in { 
                X
            }
    }
}

:: fun(() -> number())
test60_pos/0 = fun () { 
    case <> of { 
        <> when true -> let X = test47_neg/0() in { 
                X
            }
    }
}

:: fun(() -> number())
test61_neg/0 = fun () { 
    case <> of { 
        <> when true -> let X = misc:test54_unspecced() in {  | Unbound var: misc:test54_unspecced/0
                X
            }
    }
}

:: fun(() -> number())
test62_neg/0 = fun () { 
    case <> of { 
        <> when true -> let X = test54_unspecced/0() in {    | Unbound var: test54_unspecced/0
                X
            }
    }
}

:: fun(() -> fun(() -> number()))
test63_pos/0 = fun () { 
    case <> of { 
        <> when true -> let Fun = erlang:make_fun(misc, test47_neg, 0) in { 
                Fun
            }
    }
}

:: fun(() -> fun(() -> number()))
test64_pos/0 = fun () { 
    case <> of { 
        <> when true -> let var0 = test47_neg/0 in { 
                let Fun = var0 in {  Fun }
            }
    }
}

:: fun(() -> [term()])
test65_pos/0 = fun () { 
    case <> of { 
        <> when true -> let L = [] in {  L }
    }
}

:: fun(() -> {atom(), number()})
test66_pos/0 = fun () { 
    case <> of { 
        <> when true -> let X = a in { 
                let Y = 1 in { 
                    let Result = {X, Y} in { 
                        Result
                    }
                }
            }
    }
}

:: fun((atom(), number()) -> [atom() | number()])
test67_pos/2 = fun (var0, var1) { 
    case <var0, var1> of { 
        <A, N> when true -> let Head = A in { 
                let Tail = [N | []] in { 
                    let Result = [Head | Tail] in { 
                        Result
                    }
                }
            }
    }
}

:: fun(({atom()}) -> none())
test68_pos/1 = fun (var0) { 
    case var0 of {  {E, var2} when true -> E }
}

:: fun(([atom()] | [number()]) -> [atom() | number()])
test69_pos/1 = fun (var0) { 
    case var0 of {  [H | T] when true -> [H | T] }
}

:: fun(() -> [atom() | number()])
test70_neg/0 = fun () { 
    case <> of { 
        <> when true -> catch test69_pos/1([atom | []])      | catch .... Expected: [atom() | number()], Got: term()
    }
}

:: fun(() -> [atom() | number()])
test71_neg/0 = fun () { 
    case <> of { 
        <> when true -> catch test69_pos/1(atom)
    }
}

:: fun(() -> term())
test72_neg/0 = fun () { 
    case <> of { 
        <> when true -> catch test69_pos/1(atom)
    }
}

:: fun(() -> term())
test73_pos/0 = fun () { 
    case <> of { 
        <> when true -> catch test69_pos/1([atom | []])
    }
}

:: fun(() -> term())
test74_pos/0 = fun () { 
    case <> of { 
        <> when true -> let var0 = catch test69_pos/1([atom | []]) in { 
                let X = var0 in {  X }
            }
    }
}

:: fun(() -> 'ok')
test75_pos/0 = fun () { 
    case <> of { 
        <> when true -> letrec (after$^0/0 = fun () { 
                    case <> of { 
                        <> when true -> nook
                    }
                }) in { 
                try try ok of { 
                        var0 -> case var0 of { 
                            ok when true -> ok
                        }
                    }
                    catch {
                        var4, var3, var2 -> case {var4, var3, var2} of { 
                            
                        }
                    }
                     of { 
                    var5 -> after$^0/0() , var5
                }
                catch {
                    var8, var7, var6 -> case {var8, var7, var6} of { 
                        {var8, var7, var6} when true ->
                        after$^0/0() , primop:raise(var6, var7)
                    }
                }
                
            }
    }
}

:: fun((term()) -> atom())
test76_pos/1 = fun (var0) { 
    case var0 of { 
        A when erlang:is_atom(A) -> A
        var2 when true -> erlang:throw({error, not_an_atom})
    }
}

:: fun((term()) -> atom())
test77_neg/1 = fun (var0) { 
    case var0 of { 
        A when true -> catch test76_pos/1(A)                 | catch .... Expected: atom(), Got: term()
    }
}

module_info/0 = fun () { 
    case <> of { 
        <> when true -> erlang:get_module_info(misc)
    }
}

module_info/1 = fun (var0) { 
    case var0 of { 
        X when true -> erlang:get_module_info(misc, X)
    }
}
