-module(scoping)
-exports(bar/0, foo/0, module_info/0, module_info/1, test01/0, test02/0, test03/0, test04/0, test05/0, test06/0)
-file([{scoping.erl 1}])
-compile([export_all nowarn_export_all])

:: fun(() -> term())
foo/0 = fun () {
    case <> of {  <> when true -> atom }
}

:: fun(() -> term())
bar/0 = fun () {
    case <> of {  <> when true -> number }
}

:: fun(() -> {'tuple' | 'triple', atom(), number()})
test01/0 = fun () {
    case <> of {
        <> when true -> let var5, A, N = case bar/0() of {
                {A, N} when try let var0 = erlang:is_atom(A) in {
                        let var1 = erlang:is_number(N) in {
                            erlang:and(var0, var1)
                        }
                    } of {  Try -> Try }
                catch {
                    T, R -> false
                }
                 -> <tuple, A, N>
                {A, N, var7} when try let var2 = erlang:is_atom(A) in {
                        let var3 = erlang:is_number(N) in {
                            erlang:and(var2, var3)
                        }
                    } of {  Try -> Try }
                catch {
                    T, R -> false
                }
                 -> <triple, A, N>
                var4 when true -> let var8 = primop:match_fail({case_clause, var4}) in {
                        <var8, [], []>
                    }
            } in {
                let Marker = var5 in {
                    {Marker, A, N}
                }
            }
    }
}

:: fun(() -> {'an' | 'na', atom() | number(), atom() | number()})
test02/0 = fun () {
    case <> of {
        <> when true -> let var1 = foo/0() in {
                let var0 = bar/0() in {
                    case {var1, var0} of {
                        {X, Y} when true -> let var7 =
                            case <> of {
                                <> when try let var3 = erlang:is_atom(X) in {
                                        let var4 = erlang:is_number(Y) in {
                                            erlang:and(var3, var4)
                                        }
                                    } of {
                                    Try -> Try
                                }
                                catch {
                                    T, R -> false
                                }
                                 -> an
                                <> when try let var5 = erlang:is_number(X) in {
                                        let var6 = erlang:is_atom(Y) in {
                                            erlang:and(var5, var6)
                                        }
                                    } of {
                                    Try -> Try
                                }
                                catch {
                                    T, R -> false
                                }
                                 -> na
                            } in {
                                let Marker = var7 in {
                                    {Marker, X, Y}
                                }
                            }
                    }
                }
            }
    }
}

:: fun(() -> {'tuple' | 'triple', atom(), number()})
test03/0 = fun () {
    case <> of {
        <> when true -> let var4, A, N = let var9, var7 = primop:recv_peek_message() in {
                case var9 of {
                    true when true -> case var7 of {
                            {A, N} when try let var0 = erlang:is_atom(A) in {
                                    let var1 = erlang:is_number(N) in {
                                        erlang:and(var0, var1)
                                    }
                                } of {  Try -> Try
                            }
                            catch {
                                T, R -> false
                            }
                             -> primop:remove_message() , <tuple, A, N>
                            {A, N, var6} when try let var2 = erlang:is_atom(A) in {
                                    let var3 = erlang:is_number(N) in {
                                        erlang:and(var2, var3)
                                    }
                                } of {  Try -> Try
                            }
                            catch {
                                T, R -> false
                            }
                             -> primop:remove_message() , <triple, A, N>
                        }
                }
            } in {
                let Marker = var4 in {
                    {Marker, A, N}
                }
            }
    }
}

:: fun(() -> {'tuple' | 'triple' | 'timeout', atom(), number()})
test04/0 = fun () {
    case <> of {
        <> when true -> let var6, A, N = let var11, var9 = primop:recv_peek_message() in {
                case var11 of {
                    true when true -> case var9 of {
                            {A, N} when try let var2 = erlang:is_atom(A) in {
                                    let var3 = erlang:is_number(N) in {
                                        erlang:and(var2, var3)
                                    }
                                } of {  Try -> Try
                            }
                            catch {
                                T, R -> false
                            }
                             -> primop:remove_message() , <tuple, A, N>
                            {A, N, var8} when try let var4 = erlang:is_atom(A) in {
                                    let var5 = erlang:is_number(N) in {
                                        erlang:and(var4, var5)
                                    }
                                } of {  Try -> Try
                            }
                            catch {
                                T, R -> false
                            }
                             -> primop:remove_message() , <triple, A, N>
                        }
                    false when true -> let var10 = primop:recv_wait_timeout(10) in {
                            case var10 of {
                                true when true -> primop:timeout() ,
                                    let A = a in {
                                        let N = 1 in {
                                            <timeout, A, N>
                                        }
                                    }
                            }
                        }
                }
            } in {
                let Marker = var6 in {
                    {Marker, A, N}
                }
            }
    }
}

:: fun(() -> 'tuple' | 'triple')
test05/0 = fun () {
    case <> of {
        <> when true -> let var13 = letrec (after$^0/0 =
                fun () {
                    case <> of {
                        <> when true -> foo/0()
                    }
                }) in {
                try try bar/0() of {
                        var0 -> case var0 of {
                            {A, N} when try let var1 = erlang:is_atom(A) in {
                                    let var2 = erlang:is_number(N) in {
                                        erlang:and(var1, var2)
                                    }
                                } of {  Try -> Try
                            }
                            catch {
                                T, R -> false
                            }
                             -> tuple
                            {A, N, var15} when try
                                let var3 = erlang:is_atom(A) in {
                                    let var4 = erlang:is_number(N) in {
                                        erlang:and(var3, var4)
                                    }
                                } of {  Try -> Try
                            }
                            catch {
                                T, R -> false
                            }
                             -> triple
                        }
                    }
                    catch {
                        var8, var7, var6 -> case {var8, var7, var6} of {

                        }
                    }
                     of {
                    var9 -> after$^0/0() , var9
                }
                catch {
                    var12, var11, var10 -> case {var12, var11, var10} of {
                        {var12, var11, var10} when true ->
                        after$^0/0() , primop:raise(var10, var11)
                    }
                }

            } in {
                let Marker = var13 in {  Marker }
            }
    }
}

:: fun(() -> 'tuple' | 'triple' | 'error')
test06/0 = fun () {
    case <> of {
        <> when true -> let var9 = try bar/0() of {
                var0 -> case var0 of {
                    {A, N} when try let var1 = erlang:is_atom(A) in {
                            let var2 = erlang:is_number(N) in {
                                erlang:and(var1, var2)
                            }
                        } of {  Try -> Try }
                    catch {
                        T, R -> false
                    }
                     -> tuple
                    {A, N, var11} when try let var3 = erlang:is_atom(A) in {
                            let var4 = erlang:is_number(N) in {
                                erlang:and(var3, var4)
                            }
                        } of {  Try -> Try }
                    catch {
                        T, R -> false
                    }
                     -> triple
                }
            }
            catch {
                var8, var7, var6 -> case {var8, var7, var6} of {
                    {throw, var12, var13} when true ->
                    error
                }
            }
             in {
                let Marker = var9 in {  Marker }
            }
    }
}

module_info/0 = fun () {
    case <> of {
        <> when true -> erlang:get_module_info(scoping)
    }
}

module_info/1 = fun (var0) {
    case var0 of {
        X when true -> erlang:get_module_info(scoping, X)
    }
}
