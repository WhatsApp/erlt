-module(impl).

-export([gen/1]).

-include("service.hrl").

%% erlfmt-ignore
gen(#service{name = undefined}) ->
    erlang:error("no service name specified");
gen(Service) ->
    Name = Service#service.name,
    Calls = Service#service.calls,
    Casts = Service#service.casts,
    "%% generated by rpctc impl\n"
    "-module(" ++ Name  ++ ").\n"
    "-behavior(gen_server).\n"
    "\n"
    "-export([handle_call/3, handle_cast/2, init/1]).\n"
    "\n"
    "-export([start/3, stop/1, " ++ lists:join(", ", lists:map(fun fa_str/1, Calls ++ Casts)) ++ "]).\n"
    "\n"
    "-export_type([impl_module/2]).\n"
    "\n"
    "-include(\"stdt.hrl\").\n"
    "\n"
    "%% These are the callbacks for the count_server behaviour\n"
    "-struct impl_module(Input, State) :: (\n"
    "    init :: fun((Input) -> State),\n"
    "" ++ lists:join(",\n", lists:map(fun call_impl_str/1, Calls) ++ lists:map(fun cast_impl_str/1, Casts)) ++ "\n"
    ").\n"
    "\n"
    "-spec start(gen_server:name(), Input, impl_module(Input, _)) -> ok_value(pid()).\n"
    "start(Name, InitArgs, ImplModule) ->\n"
    "    {ok, Pid} = gen_server:start_link({local, Name}, ?MODULE, {ImplModule, InitArgs}, []),\n"
    "    ok_value.ok{Pid}.\n"
    "\n"
    "-spec stop(gen_server:name()) -> ok().\n"
    "stop(Name) ->\n"
    "    ok = gen_server:stop(Name),\n"
    "    ok.ok{}.\n"
    "\n"
    "" ++ lists:join("\n\n", lists:map(fun call_str/1, Calls)) ++ "\n"
    "\n"
    "" ++ lists:join("\n\n", lists:map(fun cast_str/1, Casts)) ++ "\n"
    "\n"
    "-spec init({impl_module(Input, State), Input}) -> atom_ok_value({impl_module(Input, State), State}).\n"
    "init({ImplModule, InitArgs}) ->\n"
    "    State = (ImplModule#impl_module.init)(InitArgs),\n"
    "    {ok, {ImplModule, State}}.\n"
    "\n"
    "%% -spec handle_cast\n"
    "%% " ++ lists:join(";\n%% ", lists:map(fun handle_cast_spec/1, Casts)) ++ ".\n"
    "" ++ lists:join(";\n", lists:map(fun handle_cast_str/1, Casts)) ++ ".\n"
    "\n"
    "%% -spec handle_call\n"
    "%% " ++ lists:join(";\n%% ", lists:map(fun handle_call_spec/1, Calls)) ++ ".\n"
    "" ++ lists:join(";\n", lists:map(fun handle_call_str/1, Calls)) ++ ".\n".

%% erlfmt-ignore
call_impl_str(#call{name = Name, params = Params, return = Return}) ->
    "    " ++ Name ++ " :: fun((" ++ lists:join(", ", Params) ++ ", State) -> {" ++ Return ++ ", State})".

%% erlfmt-ignore
cast_impl_str(#cast{name = Name, params = Params}) ->
    "    " ++ Name ++ " :: fun((" ++ lists:join(", ", Params) ++ ", State) -> State)".

fa_str(#call{name = Name, params = Params}) ->
    Name ++ "/" ++ itoa(length(Params) + 1);
fa_str(#cast{name = Name, params = Params}) ->
    Name ++ "/" ++ itoa(length(Params) + 1).

%% erlfmt-ignore
call_str(#call{name = Name, params = Params, return = Return}) ->
    "-spec " ++ Name ++ "(gen_server:name(), " ++ lists:join(", ", Params) ++ ") -> " ++ Return ++ ".\n"
    "" ++ Name ++ "(Name, " ++ lists:join(", ", args(0, Params)) ++ ") ->\n"
    "    gen_server:call(Name, {" ++ Name ++ ", " ++ lists:join(", ", args(0, Params)) ++ "}).".

%% erlfmt-ignore
cast_str(#cast{name = Name, params = Params}) ->
    "-spec " ++ Name ++ "(gen_server:name(), " ++ lists:join(", ", Params) ++ ") -> ok().\n"
    "" ++ Name ++ "(Name, " ++ lists:join(", ", args(0, Params)) ++ ") ->\n"
    "    ok = gen_server:cast(Name, {" ++ Name ++ ", " ++ lists:join(", ", args(0, Params)) ++ "}),\n"
    "    ok.ok{}.".

%% erlfmt-ignore
handle_cast_str(#cast{name = Name, params = Params}) ->
    "handle_cast({" ++ Name ++ ", " ++ lists:join(", ", args(0, Params)) ++ "}, {ImplModule, State}) ->\n"
    "    {noreply, {ImplModule, (ImplModule#impl_module." ++ Name ++ ")("  ++ lists:join(", ", args(0, Params)) ++ ", State)}}".

%% erlfmt-ignore
handle_call_str(#call{name = Name, params = Params}) ->
    "handle_call({" ++ Name ++ ", " ++ lists:join(", ", args(0, Params)) ++ "}, _From, {ImplModule, State}) ->\n"
    "    {Result, NewState} = (ImplModule#impl_module." ++ Name ++ ")(" ++ lists:join(", ", args(0, Params)) ++ ", State),\n"
    "    {reply, Result, {ImplModule, NewState}}".

%% erlfmt-ignore
handle_cast_spec(#cast{name = Name, params = Params}) ->
    "    ({handle_" ++ Name ++ ", " ++ lists:join(", ", Params) ++ "}, {impl_module(Input, State), State}) -> {noreply, {impl_module(Input, State), State}}".

%% erlfmt-ignore
handle_call_spec(#call{name = Name, params = Params, return = Return}) ->
    "    ({handle_" ++ Name ++ ", " ++ lists:join(", ", Params) ++ "}, pid(), {impl_module(Input, State), State}) -> {reply, " ++ Return ++ ", {impl_module(Input, State), State}}".

args(_, []) -> [];
args(N, [_ | Rest]) -> [("Arg" ++ itoa(N)) | args(N + 1, Rest)].

itoa(Int) ->
    lists:flatten(io_lib:format("~p", [Int])).
