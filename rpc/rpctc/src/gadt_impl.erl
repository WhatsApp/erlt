-module(gadt_impl).

-export([gen/1]).

-include("service.hrl").

%% erlfmt-ignore
gen(#service{name = undefined}) ->
    erlang:error("no service name specified");
gen(Service) ->
    Name = Service#service.name,
    Calls = Service#service.calls,
    Casts = Service#service.casts,
    "%% generated by rpctc gadtimpl\n"
    "-module(" ++ Name  ++ ").\n"
    "-behavior(gen_server).\n"
    "\n"
    "-export([handle_call/3, handle_cast/2, init/1]).\n"
    "\n"
    "-export([start/3, stop/1, " ++ lists:join(", ", lists:map(fun fa_str/1, Calls ++ Casts)) ++ "]).\n"
    "\n"
    "-export_type([impl_module/2]).\n"
    "\n"
    "-include(\"stdt.hrl\").\n"
    "\n"
    "%% These are the callbacks for the count_server behaviour\n"
    "-struct impl_module(Input, State) :: (\n"
    "    init :: fun((Input) -> State),\n"
    "" ++ lists:join(",\n", lists:map(fun call_impl_str/1, Calls) ++ lists:map(fun cast_impl_str/1, Casts)) ++ "\n"
    ").\n"
    "\n"
    "%% This is an enum that approximates the GADT below\n"
    "-enum call_request() :: (\n"
    "    " ++ lists:join(",\n    ", lists:map(fun enum_const_str/1, Calls)) ++ "\n"
    ").\n"
    "\n"
    "%% This generalized enum, that properly types handle_call\n"
    "%% -genum call_request(Result) :: {\n"
    "%%     " ++ lists:join(",\n%%     ", lists:map(fun genum_const_str/1, Calls)) ++ "\n"
    "%% }.\n"
    "%% Waiting on https://github.com/WhatsApp/erlt/issues/269 to uncomment this.\n"
    "\n"
    "-enum cast_request() :: (\n"
    "    " ++ lists:join(",\n    ", lists:map(fun enum_const_str/1, Casts)) ++ "\n"
    ").\n"
    "\n"
    "-spec start(gen_server:name(), Input, impl_module(Input, _)) -> ok_value(pid()).\n"
    "start(Name, InitArgs, ImplModule) ->\n"
    "    {ok, Pid} = gen_server:start_link({local, Name}, ?MODULE, {ImplModule, InitArgs}, []),\n"
    "    ok_value.ok{Pid}.\n"
    "\n"
    "-spec stop(gen_server:name()) -> ok().\n"
    "stop(Name) ->\n"
    "    ok = gen_server:stop(Name),\n"
    "    ok.ok{}.\n"
    "\n"
    "" ++ lists:join("\n\n", lists:map(fun call_str/1, Calls)) ++ "\n"
    "\n"
    "" ++ lists:join("\n\n", lists:map(fun cast_str/1, Casts)) ++ "\n"
    "\n"
    "-spec init({impl_module(Input, State), Input}) -> atom_ok_value({impl_module(Input, State), State}).\n"
    "init({ImplModule, InitArgs}) ->\n"
    "    State = (ImplModule#impl_module.init)(InitArgs),\n"
    "    {ok, {ImplModule, State}}.\n"
    "\n"
    "%% This is what the spec would like with a GADT\n"
    "%% -spec handle_call(call_request(Result), pid(), {impl_module(Input, State), State}) -> atom_reply(Result, {impl_module(Input, State), State}).\n"
    "handle_call(Request, _From, {ImplModule, State}) ->\n"
    "    case Request of\n"
    "" ++ lists:join(";\n", lists:map(fun handle_call_str/1, Calls)) ++ "\n"
    "    end.\n"
    "\n"
    "-spec handle_cast(cast_request(), {impl_module(Input, State), State}) -> atom_noreply({impl_module(Input, State), State}).\n"
    "handle_cast(Request, {ImplModule, State}) ->\n"
    "    case Request of\n"
    "" ++ lists:join(";\n", lists:map(fun handle_cast_str/1, Casts)) ++ "\n"
    "    end.\n"
    .

%% erlfmt-ignore
call_impl_str(#call{name = Name, params = Params, return = Return}) ->
    "    " ++ Name ++ " :: fun((" ++ lists:join(", ", Params) ++ ", State) -> {" ++ Return ++ ", State})".

%% erlfmt-ignore
cast_impl_str(#cast{name = Name, params = Params}) ->
    "    " ++ Name ++ " :: fun((" ++ lists:join(", ", Params) ++ ", State) -> State)".

fa_str(#call{name = Name, params = Params}) ->
    Name ++ "/" ++ itoa(length(Params) + 1);
fa_str(#cast{name = Name, params = Params}) ->
    Name ++ "/" ++ itoa(length(Params) + 1).

%% erlfmt-ignore
call_str(#call{name = Name, params = Params, return = Return}) ->
    "-spec " ++ Name ++ "(gen_server:name(), " ++ lists:join(", ", Params) ++ ") -> " ++ Return ++ ".\n"
    "" ++ Name ++ "(Name, " ++ lists:join(", ", args(0, Params)) ++ ") ->\n"
    "    gen_server:call(Name, call_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "}).".

%% erlfmt-ignore
cast_str(#cast{name = Name, params = Params}) ->
    "-spec " ++ Name ++ "(gen_server:name(), " ++ lists:join(", ", Params) ++ ") -> ok().\n"
    "" ++ Name ++ "(Name, " ++ lists:join(", ", args(0, Params)) ++ ") ->\n"
    "    ok = gen_server:cast(Name, cast_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "}),\n"
    "    ok.ok{}.".

%% erlfmt-ignore
handle_cast_str(#cast{name = Name, params = Params}) ->
    "        cast_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "} ->\n"
    "            {noreply, {ImplModule, (ImplModule#impl_module." ++ Name ++ ")(" ++ lists:join(", ", args(0, Params))  ++ ", State)}}".

%% erlfmt-ignore
handle_call_str(#call{name = Name, params = Params}) ->
    "        call_request." ++ Name ++ "{" ++ lists:join(", ", args(0, Params)) ++ "} ->\n"
    "            {Result, NewState} = (ImplModule#impl_module." ++ Name ++ ")(" ++ lists:join(", ", args(0, Params)) ++ ", State),\n"
    "            {reply, Result, {ImplModule, NewState}}".

enum_const_str(#cast{name = Name, params = Params}) ->
    Name ++ "{" ++ lists:join(", ", Params) ++ "}";
enum_const_str(#call{name = Name, params = Params}) ->
    Name ++ "{" ++ lists:join(", ", Params) ++ "}".

genum_const_str(#call{name = Name, params = Params, return = Return}) ->
    Name ++ "(" ++ lists:join(", ", Params) ++ ") -> call_request(" ++ Return ++ ")".

args(_, []) -> [];
args(N, [_ | Rest]) -> [("Arg" ++ itoa(N)) | args(N + 1, Rest)].

itoa(Int) ->
    lists:flatten(io_lib:format("~p", [Int])).
