%% generated by rpctc gadtimpl
-module(count_server).
-behavior(gen_server).

-export([handle_call/3, handle_cast/2, init/1]).

-export([start/3, stop/1, equal/2, closer/3, inc/2, dec/2]).

-export_type([impl_module/2]).

-include("stdt.hrl").

%% These are the callbacks for the count_server behaviour
-struct impl_module(Input, State) :: (
    init :: fun((Input) -> State),
    equal :: fun((integer(), State) -> {boolean(), State}),
    closer :: fun((integer(), integer(), State) -> {integer(), State}),
    inc :: fun((integer(), State) -> State),
    dec :: fun((integer(), State) -> State)
).

%% This is an enum that approximates the GADT below
-enum call_request() :: (
    equal{integer()},
    closer{integer(), integer()}
).

%% This generalized enum, that properly types handle_call
%% -genum call_request(Result) :: {
%%     equal(integer()) -> call_request(boolean()),
%%     closer(integer(), integer()) -> call_request(integer())
%% }.
%% Waiting on https://github.com/WhatsApp/erlt/issues/269 to uncomment this.

-enum cast_request() :: (
    inc{integer()},
    dec{integer()}
).

-spec start(gen_server:name(), Input, impl_module(Input, _)) -> ok_value(pid()).
start(Name, InitArgs, ImplModule) ->
    {ok, Pid} = gen_server:start_link({local, Name}, ?MODULE, {ImplModule, InitArgs}, []),
    ok_value.ok{Pid}.

-spec stop(gen_server:name()) -> ok().
stop(Name) ->
    ok = gen_server:stop(Name),
    ok.ok{}.

-spec equal(gen_server:name(), integer()) -> boolean().
equal(Name, Arg0) ->
    gen_server:call(Name, call_request.equal{Arg0}).

-spec closer(gen_server:name(), integer(), integer()) -> integer().
closer(Name, Arg0, Arg1) ->
    gen_server:call(Name, call_request.closer{Arg0, Arg1}).

-spec inc(gen_server:name(), integer()) -> ok().
inc(Name, Arg0) ->
    ok = gen_server:cast(Name, cast_request.inc{Arg0}),
    ok.ok{}.

-spec dec(gen_server:name(), integer()) -> ok().
dec(Name, Arg0) ->
    ok = gen_server:cast(Name, cast_request.dec{Arg0}),
    ok.ok{}.

-spec init({impl_module(Input, State), Input}) -> atom_ok_value({impl_module(Input, State), State}).
init({ImplModule, InitArgs}) ->
    State = (ImplModule#impl_module.init)(InitArgs),
    {ok, {ImplModule, State}}.

%% This is what the spec would like with a GADT
%% -spec handle_call(call_request(Result), pid(), {impl_module(Input, State), State}) -> atom_reply(Result, {impl_module(Input, State), State}).
handle_call(Request, _From, {ImplModule, State}) ->
    case Request of
        call_request.equal{Arg0} ->
            {Result, NewState} = (ImplModule#impl_module.equal)(Arg0, State),
            {reply, Result, {ImplModule, NewState}};
        call_request.closer{Arg0, Arg1} ->
            {Result, NewState} = (ImplModule#impl_module.closer)(Arg0, Arg1, State),
            {reply, Result, {ImplModule, NewState}}
    end.

-spec handle_cast(cast_request(), {impl_module(Input, State), State}) -> atom_noreply({impl_module(Input, State), State}).
handle_cast(Request, {ImplModule, State}) ->
    case Request of
        cast_request.inc{Arg0} ->
            {noreply, {ImplModule, (ImplModule#impl_module.inc)(Arg0, State)}};
        cast_request.dec{Arg0} ->
            {noreply, {ImplModule, (ImplModule#impl_module.dec)(Arg0, State)}}
    end.
